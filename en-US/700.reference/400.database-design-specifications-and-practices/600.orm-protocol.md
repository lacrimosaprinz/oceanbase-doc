|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# ORM conventions

Object Relational Mapping (ORM) is a programming technique that converts data between different types of systems by using object-oriented programming languages. In effect, ORM creates a "virtual object database" that can be used in programming languages.

* Do not use resultClass as the return parameter. Define the class attribute name even if all class attribute names are in one-to-one correspondence with database fields, and define a class attribute name for each table.

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>Configure mapping relationships to decouple fields from the DO class for ease of maintenance. </p>
  </main>

* Pay attention to the following parameter configuration method in the `sql.xml` file: Do not use `${}` in `#{}` or `#param#`, which may cause SQL injection.

* Do not use `queryForList(String statementName,int start,int size)` that comes with iBATIS.

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>This method obtains all records of the SQL statements with the corresponding statementName from the database, and obtains the start and size subsets through subList. This method has caused an out-of-memory (OOM) issue in the online system. To solve this problem, you can introduce <code>#start#</code> and <code>#size#</code> into sqlmap.xml. For example:</p>
    <pre><code class="language-unknow">
    Map<String, Object> map = newHashMap<String, Object>();
    map.put("start", start);
    map.put("size", size);
    </code></pre>
  </main>

* Do not directly use HashMap or HashTable as the output of a query result set.

   Here is a counter-example: To avoid writing a `<resultMap>` entry, a developer uses HashTable to receive results returned by the database. Generally, bigint values in the result are converted to Long values. However, due to database version differences in an online system, bigint values were converted into BigInteger values, causing a production issue.

* Update the `gmt_modified` field value of the record to the current time when you update records in the data table.

* Avoid creating a large and comprehensive data update API that takes the POJO class as input. It is not advisable to run a generic `update table set c1=value1,c2=value2,c3=value3;` statement without considering the specific fields to be updated. When executing an SQL statement, avoid updating fields that is not modified. Updating unmodified fields can lead to errors, hinder efficiency, and increase the storage size of binlogs.
