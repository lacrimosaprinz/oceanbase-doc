# EXPLAIN

## Purpose

You can use this statement to obtain the execution plan of an SQL statement, which can be a `SELECT`, `DELETE`, `INSERT`, `REPLACE` or `UPDATE` statement.

`EXPLAIN`, `DESCRIBE`, and `DESC` are synonyms.

## Syntax

```sql
{EXPLAIN [INTO table_name ] [SET statement_id = string]  
 | DESCRIBE
 | DESC}
[explain_type] [PRETTY | PRETTY_COLOR] dml_statement;

explain_type:
    BASIC
  | OUTLINE
  | EXTENDED
  | EXTENDED_NOADDR
  | PARTITIONS
  | FORMAT = {TRADITIONAL| JSON}

dml_statement:
    SELECT statement
  | DELETE statement
  | INSERT statement
  | REPLACE statement
```

## Parameters

| **Parameter** | **Description** |
|-------------------------------|-------------------------------------------|
| INTO table_name | The table where the execution plan obtained by `EXPLAIN` is to be stored. If you do not specify `INTO table_name`, the execution plan is stored in the `PLAN_TABLE` table by default.  |
| SET statement_id | The statement ID of the explained SQL statement, which can be used to query the execution plan of the statement later. If you do not specify `SET statement_id`, an empty string is used as the statement ID by default.  |
| PRETTY \| PRETTY_COLOR | Specifies to connect the parent and child nodes in the plan tree with tree lines or colored tree lines to make the execution plan easier to read.  |
| BASIC | The basic information about the output plan, such as the operator ID, operator name, and name of the referenced table.  |
| OUTLINE | The outline information contained in the output plan.  |
| EXTENDED | The extra information generated by `EXPLAIN`, including the input and output columns of each operator, partition information about the access table, and the active filter. If the current operator uses an index, the used index columns and extracted query range are displayed.  |
| EXTENDED_NOADDR | Specifies to display the brief extra information.  |
| PARTITIONS | Specifies to display the partition-related information.  |
| FORMAT = {TRADITIONAL\| JSON} | The output format of `EXPLAIN`. Valid values: <ul><li> `TRADITIONAL`: presents the output in the tabular format.    </li> <li> `JSON`: presents the output in the `KEY:VALUE` format. The output is displayed as JSON strings, including `EXTENDED` and `PARTITIONS` information. </li></ul> |
| dml_statement | The DML statement.  |

## Examples

* Explain an SQL query and store the obtained execution plan in the `test` table.

   ```shell
   /* Create a table named test. */
   obclient> CREATE TABLE test (statement_id VARCHAR(30), plan_id INT, gmt_create TIMESTAMP,
      remarks VARCHAR(4000), operator VARCHAR(255), options VARCHAR(255), object_node VARCHAR(40),
      object_owner VARCHAR(128), object_name VARCHAR(128), object_alias VARCHAR(261), object_instance INT,
      object_type VARCHAR(30),optimizer VARCHAR(4000), search_columns INT, id INT, parent_id INT, depth INT,
      position INT,is_last_child INT, cost INT, cardinality INT, bytes INT, rowset INT, other_tag VARCHAR(4000),
      partition_start VARCHAR(4000), partition_stop VARCHAR(4000), partition_id INT, other VARCHAR(4000),
      distribution VARCHAR(64), cpu_cost INT, io_cost INT, temp_space INT, access_predicates VARCHAR(4000),
      filter_predicates VARCHAR(4000),startup_predicates VARCHAR(4000), projection VARCHAR(4000),
      special_predicates VARCHAR(4000), time INT, qblock_name VARCHAR(128), other_xml VARCHAR(4000));
   Query OK, 0 rows affected

   obclient> CREATE TABLE t1(c1 INT);
   Query OK, 0 rows affected

   /* Explain an SQL query and store the obtained execution plan in the test table. */
   obclient> EXPLAIN INTO test SELECT COUNT(*) FROM t1;
   +--------------------------------------------------------------------------+
   | Query Plan                                                               |
   +--------------------------------------------------------------------------+
   | =================================================                        |
   | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                        |
   | -------------------------------------------------                        |
   | |0 |SCALAR GROUP BY  |    |1       |2           |                        |
   | |1 |└─TABLE FULL SCAN|t1  |1       |2           |                        |
   | =================================================                        |
   | Outputs & filters:                                                       |
   | -------------------------------------                                    |
   |   0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=256 |
   |       group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])            |
   |   1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256                  |
   |       access(nil), partitions(p0)                                        |
   |       is_index_back=false, is_global_index=false,                        |
   |       range_key([t1.__pk_increment]), range(MIN ; MAX)always true        |
   +--------------------------------------------------------------------------+
   14 rows in set

   obclient> SELECT DBMS_XPLAN.DISPLAY('TYPICAL',null,'test')\G
   *************************** 1. row ***************************
   DBMS_XPLAN.DISPLAY('TYPICAL',null,'test'):
    =================================================
   |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
   -------------------------------------------------
   |0 |SCALAR GROUP BY  |    |1       |2           |
   |1 |└─TABLE FULL SCAN|t1  |1       |2           |
   =================================================

   Outputs & filters:
   -------------------------------------
     0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=256
         group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
     1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
         access(nil), partitions(p0)
         is_index_back=false, is_global_index=false,
         range_key([t1.__pk_increment]), range(MIN ; MAX)always true
   1 row in set
   ```

* Explain an SQL query and set an ID for the statement.

   ```shell
   obclient> EXPLAIN INTO test SET statement_id='test2' SELECT COUNT(*) FROM t1;
   +--------------------------------------------------------------------------+
   | Query Plan                                                               |
   +--------------------------------------------------------------------------+
   | =================================================                        |
   | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                        |
   | -------------------------------------------------                        |
   | |0 |SCALAR GROUP BY  |    |1       |2           |                        |
   | |1 |└─TABLE FULL SCAN|t1  |1       |2           |                        |
   | =================================================                        |
   | Outputs & filters:                                                       |
   | -------------------------------------                                    |
   |   0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=256 |
   |       group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])            |
   |   1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256                  |
   |       access(nil), partitions(p0)                                        |
   |       is_index_back=false, is_global_index=false,                        |
   |       range_key([t1.__pk_increment]), range(MIN ; MAX)always true        |
   +--------------------------------------------------------------------------+
   14 rows in set

   obclient> SELECT DBMS_XPLAN.DISPLAY('TYPICAL','test2','test')\G
   *************************** 1. row ***************************
   DBMS_XPLAN.DISPLAY('TYPICAL','test2','test'): =================================================
   |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|
   -------------------------------------------------
   |0 |SCALAR GROUP BY  |    |1       |2           |
   |1 |└─TABLE FULL SCAN|t1  |1       |2           |
   =================================================

   Outputs & filters:
   -------------------------------------
     0 - output([T_FUN_COUNT_SUM(T_FUN_COUNT(*))]), filter(nil), rowset=256
         group(nil), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])
     1 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256
         access(nil), partitions(p0)
         is_index_back=false, is_global_index=false,
         range_key([t1.__pk_increment]), range(MIN ; MAX)always true
   1 row in set
   ```

* Explain an SQL query to obtain its execution plan without specifying `explain_type`.

   ```sql
   obclient> EXPLAIN SELECT * FROM t1,t2 WHERE t1.c2=t2.c2 AND t2.c1 > 4\G
   *************************** 1. row ***************************
   Query Plan:
   =======================================
   |ID|OPERATOR   |NAME|EST. ROWS|COST   |
   ---------------------------------------
   |0 |HASH JOIN  |    |9801000  |5933109|
   |1 | TABLE SCAN|t2  |10000    |6219   |
   |2 | TABLE SCAN|t1  |100000   |68478  |
   =======================================

   Outputs & filters:
   -------------------------------------
     0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil),
         equal_conds([t1.c2 = t2.c2]), other_conds(nil)
     1 - output([t2.c2], [t2.c1]), filter(nil),
         access([t2.c2], [t2.c1]), partitions(p0)
     2 - output([t1.c2], [t1.c1]), filter(nil),
         access([t1.c2], [t1.c1]), partitions(p0)
   ```

* Use the `EXTENDED_NOADDR` keyword to output additional information in the execution plan.

   ```sql
   obclient> EXPLAIN EXTENDED_NOADDR SELECT * FROM t1,t2 WHERE t1.c2=t2.c2 AND t2.c1 > 4\G
   *************************** 1. row ***************************
   Query Plan:
   =======================================
   |ID|OPERATOR   |NAME|EST. ROWS|COST   |
   ---------------------------------------
   |0 |HASH JOIN  |    |9801000  |5933109|
   |1 | TABLE SCAN|t2  |10000    |6219   |
   |2 | TABLE SCAN|t1  |100000   |68478  |
   =======================================

   Outputs & filters:
   -------------------------------------
     0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil),
         equal_conds([t1.c2 = t2.c2]), other_conds(nil)
     1 - output([t2.c2], [t2.c1]), filter(nil),
         access([t2.c2], [t2.c1]), partitions(p0),
         is_index_back=false,
         range_key([t2.c1]), range(4 ; MAX),
         range_cond([t2.c1 > 4])
     2 - output([t1.c2], [t1.c1]), filter(nil),
         access([t1.c2], [t1.c1]), partitions(p0),
         is_index_back=false,
         range_key([t1.__pk_increment], [t1.__pk_cluster_id], [t1.__pk_partition_id]), range(MIN,MIN,MIN ; MAX,MAX,MAX)always true
   ```

* Show an execution plan in the `TRADITIONAL` format.

   ```sql
   obclient> EXPLAIN FORMAT=TRADITIONAL SELECT * FROM t1,t2 WHERE t1.c2=t2.c2 AND t2.c1 > 4\G
   *************************** 1. row ***************************
   Query Plan:
   =======================================
   |ID|OPERATOR   |NAME|EST. ROWS|COST   |
   ---------------------------------------
   |0 |HASH JOIN  |    |9801000  |5933109|
   |1 | TABLE SCAN|t2  |10000    |6219   |
   |2 | TABLE SCAN|t1  |100000   |68478  |
   =======================================

   Outputs & filters:
   -------------------------------------
     0 - output([t1.c1], [t1.c2], [t2.c1], [t2.c2]), filter(nil),
         equal_conds([t1.c2 = t2.c2]), other_conds(nil)
     1 - output([t2.c2], [t2.c1]), filter(nil),
         access([t2.c2], [t2.c1]), partitions(p0)
     2 - output([t1.c2], [t1.c1]), filter(nil),
         access([t1.c2], [t1.c1]), partitions(p0)
   ```

* Show an execution plan in the `JSON` format.

   ```javascript
   obclient> EXPLAIN FORMAT=JSON SELECT * FROM t1,t2 WHERE t1.c2=t2.c2 AND t2.c1 > 4\G
   *************************** 1. row ***************************
   Query Plan: {
     "ID":2,
     "OPERATOR":"JOIN",
     "NAME":"JOIN",
     "EST.ROWS":9800999,
     "COST":5933108,
     "output": [
       "t1.c1",
       "t1.c2",
       "t2.c1",
       "t2.c2"
     ],
     "TABLE SCAN": {
       "ID":0
       "OPERATOR":"TABLE SCAN",
       "NAME":"TABLE SCAN",
       "EST.ROWS":10000,
       "COST":6218,
       "output": [
         "t2.c2",
         "t2.c1"
       ]
     },
     "TABLE SCAN": {
       "ID":1,
       "OPERATOR":"TABLE SCAN",
       "NAME":"TABLE SCAN",
       "EST.ROWS":100000,
       "COST":68477,
       "output": [
         "t1.c2",
         "t1.c1"
       ]
     }
   }
   ```
