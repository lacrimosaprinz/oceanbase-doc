# 产品动态

OceanBase 携版本 V4.3.0 震撼发布，致力于深耕典型的分析处理（AP）场景，超越了传统的事务处理（TP）结合轻量级 AP 的局限。此次更新凭借其 LSM-Tree 架构，引入了全新的列存储引擎，打破了行存与列存数据存储的界限，同时推出了基于列式数据格式的全新向量化引擎以及为列存设计的代价评估模型。这些创新极大地提升了对宽表处理的效率，显著增强了 AP 场景下的查询性能，同时依旧优雅地支持 TP 业务需求。此版本还新增了与 Oracle 兼容的物化视图功能，它通过预先计算并存储视图的查询结果，极大提升了实时查询速度，有效支持了快速报表生成和数据分析需求。内核层面的扩展包括在线 DDL、租户克隆等方便实用的特性，性能优化覆盖到了并行 DML、节点重启等关键操作，且新增了对 S3 兼容的备份与恢复支持。系统资源使用进一步优化，增强的索引监控和客户端本地导入功能，全方位提升了系统的易用性和管理便捷度。V4.3.0 版是为复杂的数据分析、实时报表生成、实时数据仓库管理，以及联机事务处理等多样化混合负载场景量身定制的理想选择。
## OLAP 能力
### 列存引擎
在大规模数据复杂分析或海量数据即席查询场景中，列式存储是 AP 数据库的关键能力之一。列式存储是一种数据文件组织方式，区别于行式存储，它将表中的数据按照列进行物理排列。数据进行列式存储时，分析场景可仅扫描用于查询计算的列数据，避免整行扫描，减少 IO 和内存等资源使用，提升计算速度。另外按列存储也天然具备更好的数据压缩条件，更易获得较高的压缩比，减少存储空间和网络传输带宽。
不过常见的列存存储引擎在实现上往往假设不会有大量随机更新, 尽量保证列存组织数据是静态的。当真正伴随大量数据随机更新时，也会不可避免的存在系统性能问题。OceanBase LSM-Tree 架构可以将基线数据和增量数据分别处理，正好可以解决这一场景问题。因此 V4.3.0 版本在当前架构基础上继续扩展支持了列存引擎，在一套代码一个架构一个 OBServer 上，实现了列存和行存数据存储一体化，兼顾 TP 和 AP 类查询性能。
为了方便 AP 业务迁移、方便老客户顺畅使用新版本，围绕列存引擎，从优化器到执行器、从 DDL 到备份恢复以及事务处理等多模块都进行了适配优化。包括基于列存的新的代价模型和向量化引擎，查询下压功能的扩展和增强，Skip Index，新的列式编码算法，自适应 Compaction 等。
业务上，用户可根据负载类型灵活设置表为行存表、列存表或行列冗余表。

[相关文档的链接]()
#### 旁路导入
OceanBase 数据库支持旁路导入的方式向数据库插入数据，即 OceanBase 数据库支持向 `data` 文件中直接写入数据的功能。旁路导入可以绕过 SQL 层的接口，直接在 `data` 文件中直接分配空间并插入数据，从而提高数据导入的效率。另外，列存表也支持旁路导入数据。
目前 OceanBase 数据库支持以下语句进行旁路导入：

-  `LOAD DATA /*+ direct */`
-  `INSERT /*+ append */ INTO SELECT`
### 向量化执行引擎 2.0
OceanBase 在早期版本已经实现了基于 Uniform 数据描述方式的向量化引擎，性能较非向量化引擎有了明显提升，但在深度 AP 场景，还有一些性能上的不足。V4.3.0 版本实现了向量化引擎 2.0 版本，更改为 Column 数据格式描述，避免了 ObDatum 维护带来的内存使用、序列化和读写访问开销。基于数据格式描述重构，新版本也对一批常用算子和表达式进行了重新实现，如 HashJoin、AGGR、HashGroupBy、Exchange(DTL Shuffle)等 10 余项算子，关系运算、逻辑运算、算数运算等 20 余项 MySQL 表达式。在后续的 V4.3.x 版本也会基于新的向量化引擎，持续补充完善其他算子和表达式的实现，以便获得 AP 场景更优性能。

- **内存格式优化**：新的内存数据格式提供了按列存放的数据结构，对于定长数据，显著减少了内存占用，提高了数据访问效率，并更好地支持使用 SIMD 进行计算加速。
- **算子性能优化**：包括 Sort、Hash Join、Hash Group By、数据 Shuffle、聚合计算等算子按新格式进行了重新设计与实现，全面提升了算子性能。

通过向量化 2.0 引擎，OceanBase 的 AP 场景查询执行性能得到显著提升。
### 物化视图
V4.3.0 版本新增物化视图（Materialized View）功能。物化视图是支撑 AP 业务的一个关键特性，它通过预计算和存储视图的查询结果，减少实时计算来提升查询性能，简化复杂查询逻辑，常用于快速报表生成和数据分析场景。
因为物化视图需要存储查询结果集来优化查询性能，而物化视图与基础表之间存在数据依赖关系，每当基础表数据发生变动时，物化视图中的数据必须进行相应更新以保持同步，所以新版本也引入了物化视图刷新机制，包括全量刷新和增量刷新两种策略。全量刷新是一种较为直接的方式，每次执行刷新操作时，系统会重新执行物化视图对应的查询语句，完整地计算并覆盖原有的视图结果数据，这种方式适用于数据量相对较小的场景。相对来讲，增量刷新仅需处理自上次刷新以来发生变更的部分。为了实现精确的增量刷新，OceanBase 实现了类似 Oracle MLOG（Materialized View Log）的物化视图日志功能，通过日志详细跟踪记录基础表的增量更新数据，从而确保物化视图能够进行快速增量刷新。增量刷新方式尤其适用于数据量庞大且变更频繁的业务场景。
## 高性能内核
### 自适应代价模型
OceanBase 历史版本代价模型是使用内部机器测算的常量参数来代表硬件系统统计信息，通过一系列公式与常量参数来描述每个算子的执行开销。而真实的业务场景中，不同硬件环境可能具备不同的 CPU 时钟频率、不同的顺序读或随机读的速度、不同的网卡带宽等，可能存在代价估算偏差，这些偏差会使得优化器无法在不同的业务环境总是生成最优计划。新版本优化代价模型实现，支持通过 DBMS_STATS 包来收集或设置系统统计信息系数，已达到代价模型自适应硬件的目的。同时也提供了 DBA_OB_AUX_STATISTICS 视图，用于展示当前租户的系统统计信息系数。
### 租户克隆
从 V4.3.0 起，OceanBase 提供完整的租户克隆功能。此功能可快速克隆指定租户，实现数据和资源的隔离，保证克隆租户的变动不会影响源租户。这一功能可应用于数据分析、应用升级前测试、DDL操作验证及回滚等场景。
V4.3.0 版本新增租户克隆特性，用户可在 SYS 租户下执行 “CREATE TENANT new_tenant_name FROM source_tenant_name WITH RESOURCE_POOL [=] resource_pool_name, UNIT [=] unit_config” 命令，对指定租户快速克隆出一个新租户。租户克隆任务执行完成后，新克隆租户为备租户，用户也可使用 “ALTER SYSTEM ACTIVATE STANDBY TENANT new_tenant_name” 将其转为主租户提供服务。新克隆租户和原始租户在初始状态下共享物理宏块，但新的数据变动和资源使用会按租户进行隔离。当用户需要对在线租户进行高资源消耗的临时数据分析或其他高风险操作时，为了避免对在线租户造成影响，可使用克隆租户完成分析或验证。同时也可将克隆租户作为容灾手段，若原始租户发生了难以恢复的误操作，可使用克隆租户进行数据回滚。
## 高可用增强
### 备份恢复支持 S3
OceanBase 的备份恢复功能已经支持两类存储介质：文件存储（NFS）和对象存储（OSS/COS）。新版本备份恢复增加支持 AWS S3（Simple Storage Service）存储服务，可以将 S3 作为日志归档和数据备份的目的端，也可以使用 S3 上的备份数据执行物理恢复。
## 易用性增强
### 索引使用监控
我们对数据库执行查询操作时，往往通过创建索引来优化查询性能。但随着数据表使用的时间增长，业务场景和操作人员不断增加，很可能会存在索引越建越多的问题。未使用的索引会浪费存储空间，也会加重 DML 操作的开销。对于这种情况，需要持续观察，删除无用的索引来给系统减负。但是仅靠人力很难识别哪些索引是无用索引，因此 OceanBase 在 V4.3.0 版本新增索引使用监控功能，用户可选择打开该功能并设置采样方式，在普通租户下会将符合规则的索引使用信息记录到内存，并以 15 分钟为周期刷新到内部表中，可通过 DBA_INDEX_USAGE 视图访问，以此来感知表上的索引是否有被引用，进而选择删除无用的索引表来释放空间。
