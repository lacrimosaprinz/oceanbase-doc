# 租户扩缩容的资源规划

在对租户进行扩缩容操作前，需要根据租户当前的资源使用情况，确认具体需要调整的资源及其容量。

## 租户扩容场景

1. 使用 root 用户登录到集群的 sys 租户。

    ```shell
    obclient -h172.30.xxx.xxx -P2883 -uroot@sys#obdemo -pxxxx -A
    ```

2. 进入 `oceanbase` 数据库。

    ```shell
    obclient> USE oceanbase;
    ```

3. 查看租户在每个 Unit 上各项资源的使用情况。

    ```shell
    obclient [oceanbase]> SELECT * FROM oceanbase.GV$OB_TENANT_RESOURCE_LIMIT WHERE TENANT_ID=1001;
    ```

    查询结果如下：

    ```shell
    +-------------+----------+-----------+--------+---------------+---------------------+-----------------+----------------+-------------+----------------------+
    | SVR_IP      | SVR_PORT | TENANT_ID |  ZONE  | RESOURCE_NAME | CURRENT_UTILIZATION | MAX_UTILIZATION | RESERVED_VALUE | LIMIT_VALUE | EFFECTIVE_LIMIT_TYPE |
    +-------------+----------+-----------+--------+---------------+---------------------+-----------------+----------------+-------------+----------------------+
    | 10.xx.xx.xx |    12104 |      1001 | zone1  | LS            |                   3 |              8  |              0 |         10  | TENANT_MEMORY        |
    | 10.xx.xx.xx |    12104 |      1001 | zone1  | TABLET        |               19800 |           29000 |              0 |      200000 | TENANT_MEMORY        |
    +-------------+----------+-----------+--------+---------------+---------------------+-----------------+----------------+-------------+----------------------+
    2 rows in set
    ```

    从第一行结果可知，租户 1001 在 `10.xx.xx.xx:12104` 节点上，当前有 3 个日志流（`CURRENT_UTILIZATION`），曾经同时存在过最多 8 个日志流（`MAX_UTILIZATION`），最大可以创建 10 个日志流（`LIMIT_VALUE`），并且这 10 个日志流的上限值由租户内存（`TENANT_MEMORY`）计算得来。

    从第二行结果可知，租户 1001 在 `10.xx.xx.xx:12104` 节点上，当前有 19800 个 TABLET（`CURRENT_UTILIZATION`），曾经同时存在过最多 29000 个 TABLET（`MAX_UTILIZATION`），最大可以创建 200000 个 TABLET（`LIMIT_VALUE`），并且这 200000 个 TABLET 的上限值是根据租户内存（`TENANT_MEMORY`）计算得来。

4. 根据实际扩容场景，计算扩容后所需的逻辑资源。

    在 OceanBase 数据库中，租户 LS 和 Tablet 相关的计算公式如下：
    
    * 租户单个节点上达到稳定状态的日志流个数：`PRIMARY_ZONE 个数 + 2`

    * 发生 Transfer 时，租户单个节点最大的临时日志流个数：`Unit 个数 * PRIMARY_ZONE 个数 * PRIMARY_ZONE 个数 - PRIMARY_ZONE 个数 * PRIMARY_ZONE 个数 + PRIMARY_ZONE 个数 + 2`

    * 租户在每个节点上能够创建 Tablet 个数的上限：`Min((MEMORY_SIZE/1G) * _max_tablet_cnt_per_gb, (MEMORY_SIZE * meta_memory_limit_percentage) / 200MB * 20000)`
    
    例如，假设租户 1001 PRIMARY_ZONE 的个数为 1， Unit 个数为 2，现在需要将租户的 PRIMARY_ZONE 个数修改为 3，则单个节点上达到稳定状态的日志流个数即为 5（3 + 2）个。如果这些日志流发生 Transfer，则同时存在最多的日志流个数 `MAX_UNTILIZATION` 可能需要达到 14，故需要对租户进行扩容，以便能够承载 14 个日志流。

5. 计算出扩容后所需的逻辑资源后，结合节点当前逻辑资源受限的因素，确认需要调整的物理资源或配置项。

    由于租户在每个节点上能创建的逻辑资源会受到各种物理资源或配置项值的限制，可以通过视图 `GV$OB_TENANT_RESOURCE_LIMIT_DETAIL` 来查看租户逻辑资源具体所受的限制及各种限制的上限值。

    ```shell
    obclient [oceanbase]> SELECT * FROM oceanbase.GV$OB_TENANT_RESOURCE_LIMIT_DETAIL;
    ```

    查询结果如下：

    ```shell
    +-------------+----------+-----------+---------------+------------------+-------------+
    | SVR_IP      | SVR_PORT | TENANT_ID | RESOURCE_NAME | LIMIT_TYPE       | LIMIT_VALUE |
    +-------------+----------+-----------+---------------+------------------+-------------+
    | 10.xx.xx.xx |    12104 |      1001 | LS            | MEMORY           |          10 |
    | 10.xx.xx.xx |    12104 |      1001 | LS            | CLOG_DISK        |          13 |
    | 10.xx.xx.xx |    12104 |      1001 | LS            | CONFIG           |         100 |
    | 10.xx.xx.xx |    12104 |      1001 | TABLET        | MEMORY           |      200000 |
    | 10.xx.xx.xx |    12104 |      1001 | TABLET        | CONFIG           |      250000 |
    +-------------+----------+-----------+---------------+------------------+-------------+
    5 rows in set
    ```

    从查询结果可知，租户 1001 在 `10.xx.xx.xx:12104` 节点上，限制创建的日志流个数的因素为：租户内存（`MEMORY`）为 10、日志盘（`CLOG_DISK`）为 13、配置项（`CONFIG`）为 100。

    根据这些上限值，可以确认需要调整的物理资源。例如，上面的示例中，如果希望单个节点最大可承载 14 个日志流，则需要调整租户内存（`MEMORY`）和日志盘（`CLOG_DISK`）。

6. 根据扩容后所需的逻辑资源，计算扩容后单个节点所需的物理资源量。

    假设扩容后，单个节点所需的最大临时日志流个数为 14，最多需要创建的 Tablet 个数为 40000 的示例如下：

    ```shell
    obclient [oceanbase]> CALL DBMS_OB_LIMIT_CALCULATOR.CALCULATE_MIN_PHY_RES_NEEDED_BY_LOGIC_RES(LS_NUM => 14, TABLET => 40000);
    ```

    计算结果如下：

    ```shell
    +------------------------+-------------+
    | PHYSICAL_RESOURCE_NAME | MIN_VALUE   |
    +------------------------+-------------+
    | MEMSTORE               |           0 |
    | MEMORY                 |  4194304000 |
    | DATA_DISK              |           0 |
    | CLOG_DISK              | 10737418240 |
    | CPU                    |           0 |
    +------------------------+-------------+
    5 rows in set
    ```

## 租户缩容场景

对于租户缩容的场景，也可以参考上述扩容场景中的方法，估算出业务运行所需的逻辑资源需求量后，再调用 `DBMS_OB_LIMIT_CALCULATOR` 系统包中的 `CALCULATE_MIN_PHY_RES_NEEDED_BY_LOGIC_RES` 子程序，计算出这些逻辑资源所需的物理资源量。

此外，在通过调整 Unit Number 实现租户缩容时，如果租户有多个 Unit，且每个 Unit 均比较空闲，可以通过以下方法选择合适的 Unit 来删除。

1. 使用 root 用户登录到集群的 sys 租户。

    ```shell
    obclient -h172.30.xxx.xxx -P2883 -uroot@sys#obdemo -pxxxx -A
    ```

2. 进入 `oceanbase` 数据库。

    ```shell
    obclient> USE oceanbase;
    ```

3. 执行以下命令，分别计算租户每个 Unit 中所需的最小物理资源。

    ```shell
    obclient [oceanbase]> CALL DBMS_OB_LIMIT_CALCULATOR.CALCULATE_MIN_PHY_RES_NEEDED_BY_UNIT(TENANT_ID => 1001, SERVER => "10.10.10.10:12104");
    ```

    执行结果的示例如下：

    ```shell
    +------------------------+-------------+
    | PHYSICAL_RESOURCE_NAME | MIN_VALUE   |
    +------------------------+-------------+
    | MEMSTORE               |           0 |
    | MEMORY                 |  4194304000 |
    | DATA_DISK              |           0 |
    | CLOG_DISK              | 10737418240 |
    | CPU                    |           0 |
    +------------------------+-------------+
    5 rows in set
    ```

    根据获取的结果，选择资源需求量最少的 Unit 进行删除，以便尽可能缩短迁移时间。

## 相关文档

* [查看租户和资源信息](../400.view-tenant-information.md)

* [通过调整资源规格实现租户扩缩容](../800.tenant-scale-in-and-out/200.adjust-resource-specifications.md)

* [通过调整 Unit Number 实现租户扩缩容](../800.tenant-scale-in-and-out/300.adjust-unit-number.md)

* [通过调整 Primary Zone 实现租户扩缩容](../800.tenant-scale-in-and-out/400.adjust-primary-zone.md)