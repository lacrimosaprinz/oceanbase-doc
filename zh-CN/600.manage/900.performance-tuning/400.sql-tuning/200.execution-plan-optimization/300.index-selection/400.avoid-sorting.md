| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 避免排序

一般来说，索引扫描的结果相对于索引列是有序的。例如，给定一个索引 `IDX(C1, C2, C3)`，扫描该索引的结果是按照 `C1, C2, C3` 有序的。这种序的性质可以用来优化带 `ORDER BY` 的查询。我们以下面这个查询为例，讨论如何构建索引进行优化。

```
CREATE TABLE T1 (C1 INT, C2 INT, C3 INT, C4 INT);

SELECT * FROM T1 WHERE C1 = 1 ORDER BY C3 LIMIT 5;
```

上面这个查询针对过滤谓词，可以在 `C1` 列上创建索引 `IDX_C1`。

```
CREATE INDEX IDX_C1 ON T1(C1);

EXPLAIN SELECT * FROM T1 WHERE C1 = 1 ORDER BY C3 LIMIT 5;
| ===========================================
|ID|OPERATOR    |NAME      |EST. ROWS|COST|
-------------------------------------------
|0 |LIMIT       |          |5        |6527|
|1 | TOP-N SORT |          |5        |6527|
|2 |  TABLE SCAN|t1(IDX_C1)|990      |5832|
===========================================

Outputs & filters:
-------------------------------------
  0 - output([t1.C1], [t1.C2], [t1.C3], [t1.C4]), filter(nil), limit(5), offset(nil)
  1 - output([t1.C1], [t1.C2], [t1.C3], [t1.C4]), filter(nil), sort_keys([t1.C3, ASC]), topn(5)
  2 - output([t1.C1], [t1.C2], [t1.C3], [t1.C4]), filter(nil),
      access([t1.C1], [t1.C2], [t1.C3], [t1.C4]), partitions(p0)
```

利用 `IDX_C1`，数据库会扫描所有满足 `C1 = 1` 的记录，然后按照 `C3` 进行堆排序，保留 `C3` 取值最小的 5 行结果。如果满足 `C1 = 1` 的记录比较多的话，扫描和堆排序的都会耗费较多的时间。这种情况下，我们可以进一步利用索引扫描结果有序的性质。我们可以在 `C1, C3` 上创建一个索引 `IDX_C1_C3`。

```
CREATE INDEX IDX_C1_C3 ON T1(C1, C3);

EXPLAIN SELECT * FROM T1 WHERE C1 = 1 ORDER BY C3 LIMIT 5;
| ============================================
|ID|OPERATOR  |NAME         |EST. ROWS|COST|
--------------------------------------------
|0 |TABLE SCAN|t1(IDX_C1_C3)|5        |111 |
============================================

Outputs & filters:
-------------------------------------
  0 - output([t1.C1], [t1.C2], [t1.C3], [t1.C4]), filter(nil),
      access([t1.C1], [t1.C2], [t1.C3], [t1.C4]), partitions(p0),
      limit(5), offset(nil)
```

这个索引有两个好处：

* `C1 = 1` 的谓词可以用来确定索引上的扫描范围。
* 扫描结果是按照 `C1, C3` 有序的。由于 `C1` 取值是固定的，因此，结果也是按照 `C3` 有序的。执行引擎只需要扫描前 5 行数据就能得到最终的查询结果。以上就是利用索引的结果序来消除排序操作。

给定一个索引 `(C1 ,C2, C3, C4)`。如果查询有 `C1, C2` 上的等值过滤条件，那么扫描结果就是按照 `C3, C4` 有序的。但如果 `C2` 上是一个非等值谓词，那么扫描结果就是按照 `C2, C3, C4` 有序的。

考虑下面这个查询，这个时候就存在两个优化方向：

* 选择 `C1, C2` 上的索引，利用更多的谓词来缩小 Query Range。
* 选择 `C1, C3` 上的索引，利用结果序来消除排序。

这两个优化方向需要综合 `C1 = 1` 和 `C2 > 1` 的谓词过滤性才能判定哪个更合适。

```
EXPLAIN SELECT * FROM T1 WHERE C1 = 1 AND C2 > 1 ORDER BY C3 LIMIT 5;
```

例如：

1. `C1 = 1` 过滤性差，`C2 > 1` 的过滤性也差，那么选择 `C1, C3` 上的索引会好一些。
2. `C1 = 1` 过滤性差，`C2 > 1` 的过滤性好，那么选择 `C1, C2` 上的索引会好一些。
3. `C1 = 1` 过滤性好，那这两个索引的性能可能是比较接近的。不会有非常大的差异。使用 `C1, C2` 上的索引，性能会更稳定些；使用 `C1, C3` 上的索引，取决于实际数据分布，有时可能可以获得更极致的性能；有时可能会得到相对较差的性能。
