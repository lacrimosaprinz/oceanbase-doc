| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 连接次序

## 什么是连接次序

对于多表连接，由于数据库每次只能连接两个数据源，所以优化器必须要按照两两一组指定连接次序。同时，一条查询可能有多种连接次序，例如 `select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;` 这条连接查询有多个可选的连接次序，其中两个可选的连接次序如下。

```
Plan 1:
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|22771533844|
|1 | HASH JOIN  |    |98010000   |23334667   |
|2 |  TABLE SCAN|T1  |100000     |42605      |
|3 |  TABLE SCAN|T2  |100000     |42605      |
|4 | TABLE SCAN |T3  |100000     |42605      |
==============================================

Plan 2:
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|22771533844|
|1 | HASH JOIN  |    |98010000   |23334667   |
|2 |  TABLE SCAN|T3  |100000     |42605      |
|3 |  TABLE SCAN|T2  |100000     |42605      |
|4 | TABLE SCAN |T1  |100000     |42605      |
==============================================
```

对于更复杂的查询，例如 `select 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;` 有更多的可选连接次序，并且对于不同的连接次序执行成本差异可能非常大，优化器需要根据一定的策略选择最优的连接次序。

## 优化器如何决策连接次序

优化器每次选择两个数据源连接，直到所有的数据源都参与连接，得到所有可能的连接次序，最后再计算每个连接次序的执行成本，基于计算的成本选择最优的连接次序。

影响优化器决策连接次序的因素非常多，例如：连接的数据量、表的列访问量、数据分布情况、连接算法以及数据表的索引。其中最容易影响优化器选择连接次序的因素是连接数据量，这个因素取决于统计信息的准确度以及优化器的行数估计。

## 如何控制优化器使用特定的连接次序

有两种 hint 控制优化器的连接次序选择。

一是 ORDERED，指示优化器不去考虑其他连接次序，选择查询定义的连接次序连接。例如 `select /*+ORDERED*/ 1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1;`，优化器只会选择 `t1 join t2 join t3` 这一种连接次序生成计划。

```
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|65343614674|
|1 | HASH JOIN  |    |98010000   |66674090   |
|2 |  TABLE SCAN|T1  |100000     |61860      |
|3 |  TABLE SCAN|T2  |100000     |61860      |
|4 | TABLE SCAN |T3  |100000     |61860      |
==============================================
```

另外一个是 LEADING，通过这个 hint 我们可以控制优化器确定全部或部分连接次序。例如 `select /*+leading(t1 t3 t4 t2)*/ 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;`，通过 LEADING 指定完整的连接次序。

```
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T1  |100000        |61860         |
|4 |   TABLE SCAN|T3  |100000        |61860         |
|5 |  TABLE SCAN |T4  |100000        |61860         |
|6 | TABLE SCAN  |T2  |100000        |61860         |
=====================================================
```

同时也可以指定部分连接次序，剩下的表由优化器决定连接次序。例如 `select /*+leading(t3 t1)*/ 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;`，优化器可能考虑以下几个连接次序。

```
Query Plan1:
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T3  |100000        |61860         |
|4 |   TABLE SCAN|T1  |100000        |61860         |
|5 |  TABLE SCAN |T4  |100000        |61860         |
|6 | TABLE SCAN  |T2  |100000        |61860         |
=====================================================

Query Plan2:
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T3  |100000        |61860         |
|4 |   TABLE SCAN|T1  |100000        |61860         |
|5 |  TABLE SCAN |T2  |100000        |61860         |
|6 | TABLE SCAN  |T4  |100000        |61860         |
=====================================================
```

然后由优化器通过成本决策最优连接次序。

## 如何简单的判断优化器选择的连接次序不优

业务中遇到的连接次序不优问题基本上是统计信息不准确或者行数估计不准确，当遇到慢查询问题时，首先可以通过确认基表的行数估计是否准确，如果发现某张表的行数估计偏差较大，基本上优化器选择的连接次序成本不是最低的。例如 `select 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1 and t1.c2=2 and t4.c2=1` 的计划执行很慢。

```
=========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST   |
-----------------------------------------
|0 |HASH JOIN    |    |9686572  |2563762|
|1 | HASH JOIN   |    |9884     |184590 |
|2 |  HASH JOIN  |    |11       |97710  |
|3 |   TABLE SCAN|T1  |10       |48849  |
|4 |   TABLE SCAN|T4  |10       |48849  |
|5 |  TABLE SCAN |T2  |100000   |42605  |
|6 | TABLE SCAN  |T3  |100000   |42605  |
=========================================
```

通过构造 SQL 确认基表行数信息，例如确认 T1 的行数 `select count(*) from t1 where t1.c2=2;`，发现真实的行数有 100w 行，说明在错误的行数估计下，优化器选择的连接次序不优，需要通过 leading hint 控制优化器选择的连接次序。例如 `leading(t3 (t2 (t4 t1)))`。
