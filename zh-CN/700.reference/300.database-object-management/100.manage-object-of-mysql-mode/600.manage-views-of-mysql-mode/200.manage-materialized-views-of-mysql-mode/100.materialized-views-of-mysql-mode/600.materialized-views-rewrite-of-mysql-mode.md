|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|MySQL Mode|

# 物化视图查询改写

通过使用物化视图来加速查询，当输入一个不使用物化视图的查询时，系统会自动将查询重写为使用现有物化视图的查询。该方法的原理是将查询语句与物化视图的定义进行匹配，如果发现匹配的物化视图，则自动将查询重写为使用物化视图的查询，这样可以大大提高查询性能和效率。

OceanBase 数据库当前版本的物化视图查询改写主要为了支持收藏夹的场景。

## 物化视图查询改写使用要求

* 物化视图满足以下要求：

  * 创建物化视图时，指定 `ENABLE QUERY REWRITE` 开启当前物化视图的自动改写。
  * 需要物化视图仅包含 `SELECT JOIN` 与 `WHERE` 子句，即 SPJ 查询。对于不满足条件的物化视图，不会报错，但不会被用于改写。

* 当前查询满足以下要求：

  * 查询为 `SELECT` 查询，不是集合查询或层次查询，并且不包含窗口函数。
  * `FROM` 子句与物化视图完全匹配。
  * `WHERE` 条件物化视图是当前查询的子集，当前查询有聚合的情况下需要完全匹配。例如，物化视图的 `WHERE` 是 `c1 > 10`，当前查询的 `WHERE` 是 `c1 > 10 AND c2 >20`。这样物化视图的条件 {c1 > 10} 是当前查询 {c1>10, c2>20} 的子集。
  * `SELECT` 项、当前查询多余的 `WHERE`/`HAVING` 条件、`GROUP BY` 列等需要物化视图的 `SELECT` 中包含所需的列。

## 规则/代价检查

查询改写时，OceanBase 数据库当前版本不进行代价检查，但规则检查要求改写后的 `WHERE` 条件能够使用至少一个物化视图上的索引。此外，当前的改写机制仅支持前 10 个物化视图，超过 10 个物化视图将不会被匹配到适用的物化视图进行改写。

## 物化视图改写

控制物化视图查询改写的系统变量如下：

* `query_rewrite_enabled`：用于是否开启物化视图改写功能。该变量的详细介绍信息，参见 [query_rewrite_enabled](../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/11050.query_rewrite_enabled-global.md)。

    **示例如下：**

    ```sql
    SET query_rewrite_enabled = 'force';
    ```

* `query_rewrite_integrity`：用于指定物化视图改写的数据一致性检查级别。该变量的详细介绍信息，参见 [query_rewrite_integrity](../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/11060.query_rewrite_integrity-global.md)。

    **示例如下：**

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

**通过以下示例展示物化视图改写：**

1. 创建表 `test_tbl1`。

    ```sql
    CREATE TABLE test_tbl1 (col1 INT, col2 INT, col3 INT);
    ```

2. 创建表 `test_tbl2`。

    ```sql
    CREATE TABLE test_tbl2 (col1 INT, col2 INT, col3 INT);
    ```

3. 创建名为 `mv_test_tbl1_tbl2` 的物化视图，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv_test_tbl1_tbl2
        ENABLE QUERY REWRITE
        AS SELECT t1.col1 col1, t1.col2 t1col2, t1.col3 t1col3, t2.col2 t2col2, t2.col3 t2col3 
        FROM test_tbl1 t1, test_tbl2 t2
        WHERE t1.col1 = t2.col1;
    ```

4. 当输入查询 `SELECT count(*), test_tbl1.col1 col1 FROM test_tbl1, test_tbl2 WHERE test_tbl1.col1 = test_tbl2.col1 AND test_tbl2.col2 > 10 GROUP BY col1;` 时，发生物化视图查询改写。

    ```sql
    SELECT count(*), test_tbl1.col1 col1 FROM test_tbl1, test_tbl2 WHERE test_tbl1.col1 = test_tbl2.col1 AND test_tbl2.col2 > 10 GROUP BY col1;

    MV REWRITE ==>

    SELECT count(*), mv_test_tbl1_tbl2.col1 col1 FROM mv_test_tbl1_tbl2 WHERE mv_test_tbl1_tbl2.t2col2 > 10 GROUP BY mv_test_tbl1_tbl2.col1;
    ```

    物化视图查询改写要求输入的查询与物化视图的 `FROM` 完全匹配，`WHERE` 条件包含物化视图中的所有 `WHERE` 条件。

## 物化视图查询改写控制

物化视图查询改写控制包括 `MV_REWRITE`、`NO_MV_REWRITE` 两个 Hint，并且这两个 Hint 的优先级高于系统变量 `query_rewrite_enabled`。

### MV_REWRITE

`MV_REWRITE` 语法如下：

```sql
/*+ MV_REWRITE (@ queryblock [mv_name_list]) */

mv_name_list:
    mv_name [, mv_name ...]
```

单独使用 `MV_REWRITE` Hint 时可以跳过物化视图查询改写的规则/代价检查，直接使用可以使用的改写。Hint 后指定一个或多个物化视图的情况，除了跳过规则/代价检查外，物化视图查询改写将只使用指定的物化视图尝试改写，忽略所有没被指定的物化视图。

使用 `MV_REWRITE` Hint 指定物化视图时，无法强制使用没有 `ENABLE QUERY REWRITE`（开启当前物化视图的自动改写） 子句的物化视图，无法在系统变量 `query_rewrite_integrity` 设置为 `enforced` 的情况下强制使用非实时物化视图。

### NO_MV_REWRITE

`NO_MV_REWRITE` 语法如下：

```sql
/*+ NO_MV_REWRITE (@ queryblock) */
```

禁止物化视图查询改写，可以指定 query block。

### 物化视图查询改写控制 Hint 使用示例

1. 创建基表 `tbl2`。

    ```sql
    CREATE TABLE tbl2 (col1 INT, col2 INT);
    ```

2. 向基表 `tbl2` 中插入两条数据。

    ```sql
    INSERT INTO tbl2 VALUES (1,2),(3,4);
    ```

    返回结果如下：

    ```shell
    Query OK, 2 rows affected
    Records: 2  Duplicates: 0  Warnings: 0
    ```

3. 创建物化视图 `mv1_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv1_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2;
    ```

4. 创建物化视图 `mv2_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv2_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2 WHERE tbl2.col1 > 1;
    ```

5. 设置系统变量 `query_rewrite_integrity` 为 `stale_tolerated`。

    <main id="notice" type='explain'>
      <h4>说明</h4>
      <p><code>MV_REWRITE</code> 和 <code>NO_MV_REWRITE</code> Hint 的优先级高于系统变量 <code>query_rewrite_enabled</code>，因此不需要设置 <code>query_rewrite_enabled</code>。但是需要设置 <code>query_rewrite_integrity</code> 为 <code>stale_tolerated</code> 才可以使用非实时物化视图进行改写。</p>
    </main>

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

6. 使用 `MV_REWRITE` Hint 用物化视图尝试进行改写，并跳过改写代价/规则检查。下面两条查询都将使用物化视图 `mv1_tbl2` 进行改写。

   * `/*+mv_rewrite*/` 将尝试使用所有符合改写条件的物化视图进行改写，一旦找到了符合改写要求的物化视图，后续的物化视图将不再被考虑，并跳过改写代价/规则检查。

       ```sql
       EXPLAIN SELECT /*+mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
       ```

       返回结果如下：

       ```shell
       +------------------------------------------------------------------------------------+
       | Query Plan                                                                         |
       +------------------------------------------------------------------------------------+
       | =====================================================                              |
       | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                              |
       | -----------------------------------------------------                              |
       | |0 |HASH GROUP BY    |        |1       |3           |                              |
       | |1 |└─TABLE FULL SCAN|mv1_tbl2|1       |3           |                              |
       | =====================================================                              |
       | Outputs & filters:                                                                 |
       | -------------------------------------                                              |
       |   0 - output([T_FUN_COUNT(*)], [mv1_tbl2.col1]), filter(nil), rowset=16            |
       |       group([mv1_tbl2.col1]), agg_func([T_FUN_COUNT(*)])                           |
       |   1 - output([mv1_tbl2.col1]), filter([mv1_tbl2.col1 > 1]), rowset=16              |
       |       access([mv1_tbl2.col1]), partitions(p0)                                      |
       |       is_index_back=false, is_global_index=false, filter_before_indexback[false],  |
       |       range_key([mv1_tbl2.__pk_increment]), range(MIN ; MAX)always true            |
       +------------------------------------------------------------------------------------+
       14 rows in set
       ```

   * `/*+mv_rewrite(mv2_tbl2)*/` 将尝试使用 `mv2_tbl2` 进行改写，并跳过改写代价/规则检查。

        ```sql
        EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
        ```

        返回结果如下：

        ```shell
        +-------------------------------------------------------------------------+
        | Query Plan                                                              |
        +-------------------------------------------------------------------------+
        | =====================================================                   |
        | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                   |
        | -----------------------------------------------------                   |
        | |0 |HASH GROUP BY    |        |1       |3           |                   |
        | |1 |└─TABLE FULL SCAN|mv2_tbl2|1       |3           |                   |
        | =====================================================                   |
        | Outputs & filters:                                                      |
        | -------------------------------------                                   |
        |   0 - output([T_FUN_COUNT(*)], [mv2_tbl2.col1]), filter(nil), rowset=16 |
        |       group([mv2_tbl2.col1]), agg_func([T_FUN_COUNT(*)])                |
        |   1 - output([mv2_tbl2.col1]), filter(nil), rowset=16                   |
        |       access([mv2_tbl2.col1]), partitions(p0)                           |
        |       is_index_back=false, is_global_index=false,                       |
        |       range_key([mv2_tbl2.__pk_increment]), range(MIN ; MAX)always true |
        +-------------------------------------------------------------------------+
        14 rows in set
        ```

7. 由于 `mv2_tbl2` 无法用于下面查询的改写（`WHERE` 条件不满足），下面的查询只尝试使用 `mv2_tbl2`，因此无法使用其他物化视图查询改写，不会进行物化视图查询改写。

    ```sql
    EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 < 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +------------------------------------------------------------------------------------+
    | Query Plan                                                                         |
    +------------------------------------------------------------------------------------+
    | =================================================                                  |
    | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                  |
    | -------------------------------------------------                                  |
    | |0 |HASH GROUP BY    |    |1       |3           |                                  |
    | |1 |└─TABLE FULL SCAN|tbl2|1       |3           |                                  |
    | =================================================                                  |
    | Outputs & filters:                                                                 |
    | -------------------------------------                                              |
    |   0 - output([T_FUN_COUNT(*)], [tbl2.col1]), filter(nil), rowset=16                |
    |       group([tbl2.col1]), agg_func([T_FUN_COUNT(*)])                               |
    |   1 - output([tbl2.col1]), filter([tbl2.col1 < 1]), rowset=16                      |
    |       access([tbl2.col1]), partitions(p0)                                          |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],  |
    |       range_key([tbl2.__pk_increment]), range(MIN ; MAX)always true                |
    +------------------------------------------------------------------------------------+
    14 rows in set
    ```

8. 使用 `/*+ no_mv_rewrite*/` Hint，不会进行物化视图查询改写。

    ```sql
    EXPLAIN SELECT /*+no_mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +------------------------------------------------------------------------------------+
    | Query Plan                                                                         |
    +------------------------------------------------------------------------------------+
    | =================================================                                  |
    | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                  |
    | -------------------------------------------------                                  |
    | |0 |HASH GROUP BY    |    |1       |3           |                                  |
    | |1 |└─TABLE FULL SCAN|tbl2|1       |3           |                                  |
    | =================================================                                  |
    | Outputs & filters:                                                                 |
    | -------------------------------------                                              |
    |   0 - output([T_FUN_COUNT(*)], [tbl2.col1]), filter(nil), rowset=16                |
    |       group([tbl2.col1]), agg_func([T_FUN_COUNT(*)])                               |
    |   1 - output([tbl2.col1]), filter([tbl2.col1 > 1]), rowset=16                      |
    |       access([tbl2.col1]), partitions(p0)                                          |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],  |
    |       range_key([tbl2.__pk_increment]), range(MIN ; MAX)always true                |
    +------------------------------------------------------------------------------------+
    14 rows in set
    ```

## 收藏夹物化视图查询改写示例

1. 修改控制物化视图查询改写的系统变量的值。

    ```sql
    SET query_rewrite_enabled = 'true';
    ```

    ```sql
    SET query_rewrite_integrity = 'enforced';
    ```

2. 创建基表 `collect_info` 和 `collect_item`。

    ```sql
    CREATE TABLE collect_info(user_id INT,
        item_id INT,
        user_name VARCHAR(1000),
        PRIMARY KEY(user_id, item_id)
        ) PARTITION BY HASH(user_id) PARTITIONS 16;
    ```

    ```sql
    CREATE TABLE collect_item(item_id INT,
        item_type INT,
        price INT,
        pic_url VARCHAR(1000),
        PRIMARY KEY(item_id)
        ) PARTITION BY HASH(item_id) PARTITIONS 16;
    ```

3. 在表 `collect_info` 和表 `collect_item` 上创建物化视图日志。

    ```sql
    CREATE MATERIALIZED VIEW LOG ON collect_info WITH PRIMARY KEY, ROWID, SEQUENCE (user_name) INCLUDING NEW VALUES;
    ```

    ```sql
    CREATE MATERIALIZED VIEW LOG ON collect_item WITH PRIMARY KEY, ROWID, SEQUENCE (item_type, price, pic_url) INCLUDING NEW VALUES;
    ```

4. 创建实时物化视图 `collect_mv`。

    ```sql
    CREATE MATERIALIZED VIEW collect_mv
        NEVER REFRESH
        ENABLE ON QUERY COMPUTATION
        ENABLE QUERY REWRITE
        AS SELECT collect_info.user_id uid,
                collect_info.item_id uiid,
                collect_item.item_id iid,
                collect_item.item_type itype,
                collect_item.price price,
                collect_item.pic_url pic
            FROM collect_info, collect_item
            WHERE collect_info.item_id = collect_item.item_id;
    ```

5. 在物化视图 `collect_mv` 上创建索引 `idx_collect_mv`。

    ```sql
    CREATE INDEX idx_collect_mv ON collect_mv(uid);
    ```

6. SPJ 查询：查询 `collect_info` 表的 `user_id` 字段以及 `collect_item` 表的所有列的数据。接下来，对两个表进行连接操作，使用 `WHERE` 子句中的条件 `collect_info.item_id = collect_item.item_id` 进行匹配。然后，系统会对连接的结果进行进一步筛选，以筛选出满足 `user_id = 10000` 的行。

    ```sql
    EXPLAIN SELECT collect_info.user_id uid, collect_item.*
        FROM collect_info, collect_item
        WHERE collect_info.item_id = collect_item.item_id
            AND user_id = 10000;
    ```

    返回结果如下：

    ```shell
    +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Query Plan                                                                                                                                                                 |
    +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | ============================================================================================                                                                               |
    | |ID|OPERATOR                              |NAME                      |EST.ROWS|EST.TIME(us)|                                                                               |
    | --------------------------------------------------------------------------------------------                                                                               |
    | |0 |PX COORDINATOR                        |                          |2       |128         |                                                                               |
    | |1 |└─EXCHANGE OUT DISTR                  |:EX10003                  |2       |127         |                                                                               |
    | |2 |  └─UNION ALL                         |                          |2       |124         |                                                                               |
    | |3 |    ├─NESTED-LOOP ANTI JOIN           |                          |1       |29          |                                                                               |
    | |4 |    │ ├─EXCHANGE IN DISTR             |                          |1       |10          |                                                                               |
    | |5 |    │ │ └─EXCHANGE OUT DISTR (PKEY)   |:EX10000                  |1       |10          |                                                                               |
    | |6 |    │ │   └─HASH RIGHT ANTI JOIN      |                          |1       |10          |                                                                               |
    | |7 |    │ │     ├─SUBPLAN SCAN            |VIEW1                     |1       |3           |                                                                               |
    | |8 |    │ │     │ └─TABLE RANGE SCAN      |mlog$_collect_info        |1       |3           |                                                                               |
    | |9 |    │ │     └─TABLE RANGE SCAN        |collect_mv(idx_collect_mv)|1       |8           |                                                                               |
    | |10|    │ └─SUBPLAN SCAN                  |VIEW2                     |1       |287         |                                                                               |
    | |11|    │   └─PX PARTITION ITERATOR       |                          |1       |287         |                                                                               |
    | |12|    │     └─TABLE RANGE SCAN          |mlog$_collect_item        |1       |287         |                                                                               |
    | |13|    ├─NESTED-LOOP ANTI JOIN           |                          |1       |43          |                                                                               |
    | |14|    │ ├─NESTED-LOOP JOIN              |                          |1       |24          |                                                                               |
    | |15|    │ │ ├─EXCHANGE IN DISTR           |                          |1       |5           |                                                                               |
    | |16|    │ │ │ └─EXCHANGE OUT DISTR (PKEY) |:EX10001                  |1       |5           |                                                                               |
    | |17|    │ │ │   └─MERGE JOIN              |                          |1       |5           |                                                                               |
    | |18|    │ │ │     ├─SUBPLAN SCAN          |VIEW6                     |1       |3           |                                                                               |
    | |19|    │ │ │     │ └─MERGE DISTINCT      |                          |1       |3           |                                                                               |
    | |20|    │ │ │     │   └─SUBPLAN SCAN      |VIEW3                     |1       |3           |                                                                               |
    | |21|    │ │ │     │     └─TABLE RANGE SCAN|mlog$_collect_info        |1       |3           |                                                                               |
    | |22|    │ │ │     └─TABLE RANGE SCAN      |collect_info              |1       |3           |                                                                               |
    | |23|    │ │ └─PX PARTITION ITERATOR       |                          |1       |287         |                                                                               |
    | |24|    │ │   └─TABLE GET                 |collect_item              |1       |287         |                                                                               |
    | |25|    │ └─SUBPLAN SCAN                  |VIEW4                     |1       |287         |                                                                               |
    | |26|    │   └─PX PARTITION ITERATOR       |                          |1       |287         |                                                                               |
    | |27|    │     └─TABLE RANGE SCAN          |mlog$_collect_item        |1       |287         |                                                                               |
    | |28|    └─HASH JOIN                       |                          |1       |54          |                                                                               |
    | |29|      ├─EXCHANGE IN DISTR             |                          |1       |4           |                                                                               |
    | |30|      │ └─EXCHANGE OUT DISTR (PKEY)   |:EX10002                  |1       |3           |                                                                               |
    | |31|      │   └─TABLE RANGE SCAN          |collect_info              |1       |3           |                                                                               |
    | |32|      └─PX PARTITION ITERATOR         |                          |1       |50          |                                                                               |
    | |33|        └─NESTED-LOOP JOIN            |                          |1       |50          |                                                                               |
    | |34|          ├─SUBPLAN SCAN              |VIEW7                     |1       |34          |                                                                               |
    | |35|          │ └─MERGE DISTINCT          |                          |1       |34          |                                                                               |
    | |36|          │   └─SUBPLAN SCAN          |VIEW5                     |1       |34          |                                                                               |
    | |37|          │     └─TABLE FULL SCAN     |mlog$_collect_item        |1       |34          |                                                                               |
    | |38|          └─TABLE GET                 |collect_item              |1       |246         |                                                                               |
    | ============================================================================================                                                                               |
    | Outputs & filters:                                                                                                                                                         |
    | -------------------------------------                                                                                                                                      |
    |   0 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]), UNION([3]), UNION([4]), UNION([5]))]), filter(nil), rowset=16                                                      |
    |   1 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]), UNION([3]), UNION([4]), UNION([5]))]), filter(nil), rowset=16                                                      |
    |       dop=1                                                                                                                                                                |
    |   2 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])], [UNION([5])]), filter(nil), rowset=16                                                                 |
    |   3 - output([collect_mv.uid], [collect_mv.iid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), filter(nil), rowset=16                                         |
    |       conds(nil), nl_params_([collect_mv.iid(:1)]), use_batch=false                                                                                                        |
    |   4 - output([PARTITION_ID], [collect_mv.iid], [collect_mv.uid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), filter(nil), rowset=16                         |
    |   5 - output([PARTITION_ID], [collect_mv.iid], [collect_mv.uid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), filter(nil), rowset=16                         |
    |       (#keys=1, [collect_mv.iid]), is_single, dop=1                                                                                                                        |
    |   6 - output([collect_mv.iid], [collect_mv.uid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), filter(nil), rowset=16                                         |
    |       equal_conds([collect_mv.uiid = VIEW1.mlog$_collect_info.item_id]), other_conds(nil)                                                                                  |
    |   7 - output([VIEW1.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                                                                   |
    |       access([VIEW1.mlog$_collect_info.item_id])                                                                                                                           |
    |   8 - output([mlog$_collect_info.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                                                     |
    |       access([mlog$_collect_info.item_id], [ORA_ROWSCN]), partitions(p0)                                                                                                   |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                          |
    |       range_key([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [mlog$_collect_info.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),                        |
    |       range_cond([mlog$_collect_info.user_id = 10000])                                                                                                                     |
    |   9 - output([collect_mv.uid], [collect_mv.uiid], [collect_mv.iid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), filter(nil), rowset=16                      |
    |       access([collect_mv.__pk_increment], [collect_mv.uid], [collect_mv.uiid], [collect_mv.iid], [collect_mv.itype], [collect_mv.price], [collect_mv.pic]), partitions(p0) |
    |       is_index_back=true, is_global_index=false,                                                                                                                           |
    |       range_key([collect_mv.uid], [collect_mv.__pk_increment]), range(10000,MIN ; 10000,MAX),                                                                              |
    |       range_cond([collect_mv.uid = 10000])                                                                                                                                 |
    |  10 - output(nil), filter(nil), rowset=16                                                                                                                                  |
    |       access(nil)                                                                                                                                                          |
    |  11 - output([mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                                         |
    |       affinitize, partition wise, force partition granule                                                                                                                  |
    |  12 - output([mlog$_collect_item.item_id], [ORA_ROWSCN]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                                       |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                          |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                                       |
    |       range_cond([:1 = mlog$_collect_item.item_id])                                                                                                                        |
    |  13 - output([collect_info.user_id], [collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16               |
    |       conds(nil), nl_params_([collect_item.item_id(:8)]), use_batch=false                                                                                                  |
    |  14 - output([collect_item.item_id], [collect_info.user_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16               |
    |       conds(nil), nl_params_([collect_info.item_id(:2)]), use_batch=false                                                                                                  |
    |  15 - output([collect_info.user_id], [PARTITION_ID], [collect_info.item_id]), filter(nil), rowset=16                                                                       |
    |  16 - output([collect_info.user_id], [PARTITION_ID], [collect_info.item_id]), filter(nil), rowset=16                                                                       |
    |       (#keys=1, [collect_info.item_id]), is_single, dop=1                                                                                                                  |
    |  17 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                                       |
    |       equal_conds([collect_info.item_id = VIEW6.VIEW3.mlog$_collect_info.item_id]), other_conds(nil)                                                                       |
    |       merge_directions([ASC])                                                                                                                                              |
    |  18 - output([VIEW6.VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                                                             |
    |       access([VIEW6.VIEW3.mlog$_collect_info.item_id])                                                                                                                     |
    |  19 - output([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                               |
    |       distinct([VIEW3.mlog$_collect_info.item_id])                                                                                                                         |
    |  20 - output([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                               |
    |       access([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id])                                                                                       |
    |  21 - output([mlog$_collect_info.user_id], [mlog$_collect_info.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                       |
    |       access([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [ORA_ROWSCN]), partitions(p0)                                                                     |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                          |
    |       range_key([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [mlog$_collect_info.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),                        |
    |       range_cond([mlog$_collect_info.user_id = 10000])                                                                                                                     |
    |  22 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                                       |
    |       access([collect_info.user_id], [collect_info.item_id]), partitions(p0)                                                                                               |
    |       is_index_back=false, is_global_index=false,                                                                                                                          |
    |       range_key([collect_info.user_id], [collect_info.item_id]), range(10000,MIN ; 10000,MAX),                                                                             |
    |       range_cond([collect_info.user_id = 10000])                                                                                                                           |
    |  23 - output([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16                                       |
    |       affinitize, partition wise, force partition granule                                                                                                                  |
    |  24 - output([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16                                       |
    |       access([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), partitions(p[0-15])                                          |
    |       is_index_back=false, is_global_index=false,                                                                                                                          |
    |       range_key([collect_item.item_id]), range(MIN ; MAX),                                                                                                                 |
    |       range_cond([:2 = collect_item.item_id])                                                                                                                              |
    |  25 - output(nil), filter(nil), rowset=16                                                                                                                                  |
    |       access(nil)                                                                                                                                                          |
    |  26 - output([mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                                         |
    |       affinitize, partition wise, force partition granule                                                                                                                  |
    |  27 - output([mlog$_collect_item.item_id], [ORA_ROWSCN]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                                       |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                          |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                                       |
    |       range_cond([:8 = mlog$_collect_item.item_id])                                                                                                                        |
    |  28 - output([collect_info.user_id], [collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16               |
    |       equal_conds([collect_info.item_id = collect_item.item_id]), other_conds(nil)                                                                                         |
    |  29 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                                       |
    |  30 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                                       |
    |       (#keys=1, [collect_info.item_id]), is_single, dop=1                                                                                                                  |
    |  31 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                                       |
    |       access([collect_info.user_id], [collect_info.item_id]), partitions(p0)                                                                                               |
    |       is_index_back=false, is_global_index=false,                                                                                                                          |
    |       range_key([collect_info.user_id], [collect_info.item_id]), range(10000,MIN ; 10000,MAX),                                                                             |
    |       range_cond([collect_info.user_id = 10000])                                                                                                                           |
    |  32 - output([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16                                       |
    |       affinitize, partition wise, force partition granule                                                                                                                  |
    |  33 - output([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16                                       |
    |       conds(nil), nl_params_([VIEW7.VIEW5.mlog$_collect_item.item_id(:14)]), use_batch=false                                                                               |
    |  34 - output([VIEW7.VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                             |
    |       access([VIEW7.VIEW5.mlog$_collect_item.item_id])                                                                                                                     |
    |  35 - output([VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                                   |
    |       distinct([VIEW5.mlog$_collect_item.item_id])                                                                                                                         |
    |  36 - output([VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                                   |
    |       access([VIEW5.mlog$_collect_item.item_id])                                                                                                                           |
    |  37 - output([mlog$_collect_item.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                                                     |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                          |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true                                                        |
    |  38 - output([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), filter(nil), rowset=16                                       |
    |       access([collect_item.item_id], [collect_item.item_type], [collect_item.price], [collect_item.pic_url]), partitions(p[0-15])                                          |
    |       is_index_back=false, is_global_index=false,                                                                                                                          |
    |       range_key([collect_item.item_id]), range(MIN ; MAX),                                                                                                                 |
    |       range_cond([collect_item.item_id = :14])                                                                                                                             |
    +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    148 rows in set
    ```

7. 带有聚合的查询：对 `collect_info` 和 `collect_item` 两个表进行连接，并通过 `collect_info.item_id = collect_item.item_id` 条件进行匹配。然后，使用 `user_id = 10000` 进一步筛选数据。接下来，使用 `collect_item.item_type` 作为分组依据，将数据分组为多个组，每个组由具有相同 `item_type` 的行组成。最后，在每个分组上应用聚合函数 `count(1)`，对每个组中的行进行计数。这样可以得到每个物品类型（`item_type`）的记录数量。

    ```sql
    EXPLAIN SELECT collect_info.user_id uid, collect_item.item_type, count(1)
        FROM collect_info, collect_item
        WHERE collect_info.item_id = collect_item.item_id
            AND user_id = 10000
        GROUP BY collect_item.item_type;
    ```

    返回结果如下：

    ```shell
    +------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Query Plan                                                                                                                                           |
    +------------------------------------------------------------------------------------------------------------------------------------------------------+
    | ======================================================================================================                                               |
    | |ID|OPERATOR                                        |NAME                      |EST.ROWS|EST.TIME(us)|                                               |
    | ------------------------------------------------------------------------------------------------------                                               |
    | |0 |PX COORDINATOR                                  |                          |2       |127         |                                               |
    | |1 |└─EXCHANGE OUT DISTR                            |:EX10004                  |2       |127         |                                               |
    | |2 |  └─HASH GROUP BY                               |                          |2       |126         |                                               |
    | |3 |    └─EXCHANGE IN DISTR                         |                          |2       |125         |                                               |
    | |4 |      └─EXCHANGE OUT DISTR (HASH)               |:EX10003                  |2       |125         |                                               |
    | |5 |        └─HASH GROUP BY                         |                          |2       |124         |                                               |
    | |6 |          └─SUBPLAN SCAN                        |RT_collect_mv             |2       |124         |                                               |
    | |7 |            └─UNION ALL                         |                          |2       |124         |                                               |
    | |8 |              ├─NESTED-LOOP ANTI JOIN           |                          |1       |28          |                                               |
    | |9 |              │ ├─EXCHANGE IN DISTR             |                          |1       |10          |                                               |
    | |10|              │ │ └─EXCHANGE OUT DISTR (PKEY)   |:EX10000                  |1       |10          |                                               |
    | |11|              │ │   └─HASH RIGHT ANTI JOIN      |                          |1       |10          |                                               |
    | |12|              │ │     ├─SUBPLAN SCAN            |VIEW1                     |1       |3           |                                               |
    | |13|              │ │     │ └─TABLE RANGE SCAN      |mlog$_collect_info        |1       |3           |                                               |
    | |14|              │ │     └─TABLE RANGE SCAN        |collect_mv(idx_collect_mv)|1       |7           |                                               |
    | |15|              │ └─SUBPLAN SCAN                  |VIEW2                     |1       |287         |                                               |
    | |16|              │   └─PX PARTITION ITERATOR       |                          |1       |287         |                                               |
    | |17|              │     └─TABLE RANGE SCAN          |mlog$_collect_item        |1       |287         |                                               |
    | |18|              ├─NESTED-LOOP ANTI JOIN           |                          |1       |43          |                                               |
    | |19|              │ ├─NESTED-LOOP JOIN              |                          |1       |24          |                                               |
    | |20|              │ │ ├─EXCHANGE IN DISTR           |                          |1       |5           |                                               |
    | |21|              │ │ │ └─EXCHANGE OUT DISTR (PKEY) |:EX10001                  |1       |5           |                                               |
    | |22|              │ │ │   └─MERGE JOIN              |                          |1       |5           |                                               |
    | |23|              │ │ │     ├─SUBPLAN SCAN          |VIEW6                     |1       |3           |                                               |
    | |24|              │ │ │     │ └─MERGE DISTINCT      |                          |1       |3           |                                               |
    | |25|              │ │ │     │   └─SUBPLAN SCAN      |VIEW3                     |1       |3           |                                               |
    | |26|              │ │ │     │     └─TABLE RANGE SCAN|mlog$_collect_info        |1       |3           |                                               |
    | |27|              │ │ │     └─TABLE RANGE SCAN      |collect_info              |1       |3           |                                               |
    | |28|              │ │ └─PX PARTITION ITERATOR       |                          |1       |287         |                                               |
    | |29|              │ │   └─TABLE GET                 |collect_item              |1       |287         |                                               |
    | |30|              │ └─SUBPLAN SCAN                  |VIEW4                     |1       |287         |                                               |
    | |31|              │   └─PX PARTITION ITERATOR       |                          |1       |287         |                                               |
    | |32|              │     └─TABLE RANGE SCAN          |mlog$_collect_item        |1       |287         |                                               |
    | |33|              └─HASH JOIN                       |                          |1       |54          |                                               |
    | |34|                ├─PX PARTITION ITERATOR         |                          |1       |50          |                                               |
    | |35|                │ └─NESTED-LOOP JOIN            |                          |1       |50          |                                               |
    | |36|                │   ├─SUBPLAN SCAN              |VIEW7                     |1       |34          |                                               |
    | |37|                │   │ └─MERGE DISTINCT          |                          |1       |34          |                                               |
    | |38|                │   │   └─SUBPLAN SCAN          |VIEW5                     |1       |34          |                                               |
    | |39|                │   │     └─TABLE FULL SCAN     |mlog$_collect_item        |1       |34          |                                               |
    | |40|                │   └─TABLE GET                 |collect_item              |1       |246         |                                               |
    | |41|                └─EXCHANGE IN DISTR             |                          |1       |4           |                                               |
    | |42|                  └─EXCHANGE OUT DISTR (PKEY)   |:EX10002                  |1       |3           |                                               |
    | |43|                    └─TABLE RANGE SCAN          |collect_info              |1       |3           |                                               |
    | ======================================================================================================                                               |
    | Outputs & filters:                                                                                                                                   |
    | -------------------------------------                                                                                                                |
    |   0 - output([INTERNAL_FUNCTION(collect_mv.uid, collect_mv.itype, T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), rowset=16                         |
    |   1 - output([INTERNAL_FUNCTION(collect_mv.uid, collect_mv.itype, T_FUN_COUNT_SUM(T_FUN_COUNT(*)))]), filter(nil), rowset=16                         |
    |       dop=1                                                                                                                                          |
    |   2 - output([collect_mv.itype], [T_FUN_COUNT_SUM(T_FUN_COUNT(*))], [collect_mv.uid]), filter(nil), rowset=16                                        |
    |       group([collect_mv.itype]), agg_func([T_FUN_COUNT_SUM(T_FUN_COUNT(*))])                                                                         |
    |   3 - output([collect_mv.itype], [T_FUN_COUNT(*)], [collect_mv.uid]), filter(nil), rowset=16                                                         |
    |   4 - output([collect_mv.itype], [T_FUN_COUNT(*)], [collect_mv.uid]), filter(nil), rowset=16                                                         |
    |       (#keys=1, [collect_mv.itype]), dop=1                                                                                                           |
    |   5 - output([collect_mv.itype], [T_FUN_COUNT(*)], [collect_mv.uid]), filter(nil), rowset=16                                                         |
    |       group([collect_mv.itype]), agg_func([T_FUN_COUNT(*)])                                                                                          |
    |   6 - output([collect_mv.uid], [collect_mv.itype]), filter(nil), rowset=16                                                                           |
    |       access([collect_mv.uid], [collect_mv.itype])                                                                                                   |
    |   7 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16                                                                                     |
    |   8 - output([collect_mv.uid], [collect_mv.itype]), filter(nil), rowset=16                                                                           |
    |       conds(nil), nl_params_([collect_mv.iid(:1)]), use_batch=false                                                                                  |
    |   9 - output([PARTITION_ID], [collect_mv.iid], [collect_mv.uid], [collect_mv.itype]), filter(nil), rowset=16                                         |
    |  10 - output([PARTITION_ID], [collect_mv.iid], [collect_mv.uid], [collect_mv.itype]), filter(nil), rowset=16                                         |
    |       (#keys=1, [collect_mv.iid]), is_single, dop=1                                                                                                  |
    |  11 - output([collect_mv.iid], [collect_mv.uid], [collect_mv.itype]), filter(nil), rowset=16                                                         |
    |       equal_conds([collect_mv.uiid = VIEW1.mlog$_collect_info.item_id]), other_conds(nil)                                                            |
    |  12 - output([VIEW1.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                                             |
    |       access([VIEW1.mlog$_collect_info.item_id])                                                                                                     |
    |  13 - output([mlog$_collect_info.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                               |
    |       access([mlog$_collect_info.item_id], [ORA_ROWSCN]), partitions(p0)                                                                             |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                    |
    |       range_key([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [mlog$_collect_info.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),  |
    |       range_cond([mlog$_collect_info.user_id = 10000])                                                                                               |
    |  14 - output([collect_mv.uid], [collect_mv.uiid], [collect_mv.iid], [collect_mv.itype]), filter(nil), rowset=16                                      |
    |       access([collect_mv.__pk_increment], [collect_mv.uid], [collect_mv.uiid], [collect_mv.iid], [collect_mv.itype]), partitions(p0)                 |
    |       is_index_back=true, is_global_index=false,                                                                                                     |
    |       range_key([collect_mv.uid], [collect_mv.__pk_increment]), range(10000,MIN ; 10000,MAX),                                                        |
    |       range_cond([collect_mv.uid = 10000])                                                                                                           |
    |  15 - output(nil), filter(nil), rowset=16                                                                                                            |
    |       access(nil)                                                                                                                                    |
    |  16 - output([mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                   |
    |       affinitize, partition wise, force partition granule                                                                                            |
    |  17 - output([mlog$_collect_item.item_id], [ORA_ROWSCN]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                 |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                        |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                    |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                 |
    |       range_cond([:1 = mlog$_collect_item.item_id])                                                                                                  |
    |  18 - output([collect_info.user_id], [collect_item.item_type]), filter(nil), rowset=16                                                               |
    |       conds(nil), nl_params_([collect_item.item_id(:8)]), use_batch=false                                                                            |
    |  19 - output([collect_item.item_id], [collect_info.user_id], [collect_item.item_type]), filter(nil), rowset=16                                       |
    |       conds(nil), nl_params_([collect_info.item_id(:2)]), use_batch=false                                                                            |
    |  20 - output([collect_info.user_id], [PARTITION_ID], [collect_info.item_id]), filter(nil), rowset=16                                                 |
    |  21 - output([collect_info.user_id], [PARTITION_ID], [collect_info.item_id]), filter(nil), rowset=16                                                 |
    |       (#keys=1, [collect_info.item_id]), is_single, dop=1                                                                                            |
    |  22 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                 |
    |       equal_conds([collect_info.item_id = VIEW6.VIEW3.mlog$_collect_info.item_id]), other_conds(nil)                                                 |
    |       merge_directions([ASC])                                                                                                                        |
    |  23 - output([VIEW6.VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                                                       |
    |       access([VIEW6.VIEW3.mlog$_collect_info.item_id])                                                                                               |
    |  24 - output([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                         |
    |       distinct([VIEW3.mlog$_collect_info.item_id])                                                                                                   |
    |  25 - output([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id]), filter(nil), rowset=16                                         |
    |       access([VIEW3.mlog$_collect_info.user_id], [VIEW3.mlog$_collect_info.item_id])                                                                 |
    |  26 - output([mlog$_collect_info.user_id], [mlog$_collect_info.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                 |
    |       access([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [ORA_ROWSCN]), partitions(p0)                                               |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                    |
    |       range_key([mlog$_collect_info.user_id], [mlog$_collect_info.item_id], [mlog$_collect_info.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),  |
    |       range_cond([mlog$_collect_info.user_id = 10000])                                                                                               |
    |  27 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                 |
    |       access([collect_info.user_id], [collect_info.item_id]), partitions(p0)                                                                         |
    |       is_index_back=false, is_global_index=false,                                                                                                    |
    |       range_key([collect_info.user_id], [collect_info.item_id]), range(10000,MIN ; 10000,MAX),                                                       |
    |       range_cond([collect_info.user_id = 10000])                                                                                                     |
    |  28 - output([collect_item.item_id], [collect_item.item_type]), filter(nil), rowset=16                                                               |
    |       affinitize, partition wise, force partition granule                                                                                            |
    |  29 - output([collect_item.item_id], [collect_item.item_type]), filter(nil), rowset=16                                                               |
    |       access([collect_item.item_id], [collect_item.item_type]), partitions(p[0-15])                                                                  |
    |       is_index_back=false, is_global_index=false,                                                                                                    |
    |       range_key([collect_item.item_id]), range(MIN ; MAX),                                                                                           |
    |       range_cond([:2 = collect_item.item_id])                                                                                                        |
    |  30 - output(nil), filter(nil), rowset=16                                                                                                            |
    |       access(nil)                                                                                                                                    |
    |  31 - output([mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                                   |
    |       affinitize, partition wise, force partition granule                                                                                            |
    |  32 - output([mlog$_collect_item.item_id], [ORA_ROWSCN]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                 |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                        |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                    |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                 |
    |       range_cond([:8 = mlog$_collect_item.item_id])                                                                                                  |
    |  33 - output([collect_info.user_id], [collect_item.item_type]), filter(nil), rowset=16                                                               |
    |       equal_conds([collect_info.item_id = collect_item.item_id]), other_conds(nil)                                                                   |
    |  34 - output([collect_item.item_type], [collect_item.item_id]), filter(nil), rowset=16                                                               |
    |       affinitize, partition wise, force partition granule                                                                                            |
    |  35 - output([collect_item.item_type], [collect_item.item_id]), filter(nil), rowset=16                                                               |
    |       conds(nil), nl_params_([VIEW7.VIEW5.mlog$_collect_item.item_id(:14)]), use_batch=false                                                         |
    |  36 - output([VIEW7.VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                       |
    |       access([VIEW7.VIEW5.mlog$_collect_item.item_id])                                                                                               |
    |  37 - output([VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                             |
    |       distinct([VIEW5.mlog$_collect_item.item_id])                                                                                                   |
    |  38 - output([VIEW5.mlog$_collect_item.item_id]), filter(nil), rowset=16                                                                             |
    |       access([VIEW5.mlog$_collect_item.item_id])                                                                                                     |
    |  39 - output([mlog$_collect_item.item_id]), filter([ORA_ROWSCN > last_refresh_scn(500280)]), rowset=16                                               |
    |       access([mlog$_collect_item.item_id], [ORA_ROWSCN]), partitions(p[0-15])                                                                        |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                    |
    |       range_key([mlog$_collect_item.item_id], [mlog$_collect_item.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true                                  |
    |  40 - output([collect_item.item_id], [collect_item.item_type]), filter(nil), rowset=16                                                               |
    |       access([collect_item.item_id], [collect_item.item_type]), partitions(p[0-15])                                                                  |
    |       is_index_back=false, is_global_index=false,                                                                                                    |
    |       range_key([collect_item.item_id]), range(MIN ; MAX),                                                                                           |
    |       range_cond([collect_item.item_id = :14])                                                                                                       |
    |  41 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                 |
    |  42 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                 |
    |       (#keys=1, [collect_info.item_id]), is_single, dop=1                                                                                            |
    |  43 - output([collect_info.user_id], [collect_info.item_id]), filter(nil), rowset=16                                                                 |
    |       access([collect_info.user_id], [collect_info.item_id]), partitions(p0)                                                                         |
    |       is_index_back=false, is_global_index=false,                                                                                                    |
    |       range_key([collect_info.user_id], [collect_info.item_id]), range(10000,MIN ; 10000,MAX),                                                       |
    |       range_cond([collect_info.user_id = 10000])                                                                                                     |
    +------------------------------------------------------------------------------------------------------------------------------------------------------+
    162 rows in set
    ```

## 相关文档

* [CREATE MATERIALIZED VIEW](../../../../../500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/600.sql-statement-of-mysql-mode/2250.create-materialized-views-of-mysql-mode-in-sql.md)
* [创建物化视图](200.create-materialized-views-of-mysql-mode.md)
* [查询物化视图](300.view-materialized-views-of-mysql-mode.md)
* [删除物化视图](400.delete-materialized-views-of-mysql-mode.md)
* [刷新物化视图](500.refresh-materialized-views-of-mysql-mode.md)
