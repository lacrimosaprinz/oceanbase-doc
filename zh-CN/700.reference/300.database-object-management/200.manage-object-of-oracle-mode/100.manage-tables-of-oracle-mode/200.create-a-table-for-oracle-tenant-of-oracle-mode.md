|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# 创建表

您可以使用 `CREATE TABLE` 语句来创建表。

本节主要介绍非分区表的创建，分区表的创建及使用请参见 [创建分区表](../200.manage-partitions-of-oracle-mode/200.create-a-partition-table-of-oracle-mode.md)。

## 创建非分区表

创建非分区表是指创建只有一个分区的表。

创建非分区表的示例语句如下：

```sql
obclient> CREATE TABLE table_name1(w_id int,
w_ytd decimal(12,2),
w_tax decimal(4,4),
w_name varchar(10),
w_street_1 varchar(20),
w_street_2 varchar(20),
w_city varchar(20),
w_state char(2),
w_zip char(9),
unique(w_name, w_city),
primary key(w_id)
);
```

```sql
obclient> CREATE TABLE table_name2 (c_w_id int NOT NULL,
c_d_id int NOT null,
c_id int NOT null,
c_discount decimal(4, 4),
c_credit char(2),
c_last varchar(16),
c_first varchar(16),
c_middle char(2),
c_balance decimal(12, 2),
c_ytd_payment decimal(12, 2),
c_payment_cnt int,
c_credit_lim decimal(12, 2),
c_street_1 varchar(20),
c_street_2 varchar(20),
c_city varchar(20),
c_state char(2),
c_zip char(9),
c_phone char(16),
c_since date,
c_delivery_cnt int,
c_data varchar(500),
FOREIGN KEY (c_w_id) REFERENCES table_name1(w_id),
primary key (c_w_id, c_d_id, c_id)
);
```

示例中创建了 2 个表，并同时对表中的列定义了一些约束信息，包括在不同列上创建的主键和外键等。更多主键、外键等的介绍，请参见 [定义列的约束类型](../100.manage-tables-of-oracle-mode/400.define-the-constraint-type-for-a-column-of-oracle-mode.md)。

创建表的列时请选择正确的数据类型，有关 SQL 数据类型的详细描述，请参见 [数据类型](../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/300.basic-elements-of-oracle-mode/200.data-type-comparison-rules-of-oracle-mode/100.overview-of-data-type-comparison-rules-of-oracle-mode.md)。

<main id="notice" type='explain'>
<h4>说明</h4>
<p>基于性能和后期维护的需要，建议建表时为表设计主键或者唯一键。如果没有合适的字段作为主键，可以为表增加一个数值列作为主键，并使用 Oracle 租户的序列为该列填充值。有关序列的介绍请参见 <a href="../600.management-sequence-of-oracle-mode.md">管理序列</a>。</p>
</main>

## 创建复制表

复制表是 OceanBase 数据库的一种特殊表。这种表可以在任意一个“健康”的副本上读取到数据的最新修改。对于写入频率要求较低、读操作延迟和负载均衡要求较高的用户来说，复制表是一种很好的选择。

当用户创建一个复制表后，所在租户的所有 OBServer 节点内都会创建一个复制表的副本，这些副本中有一个副本会被选为 Leader，接受写请求，其余的副本只能接受读请求。

所有的副本都需要向 Leader 汇报状态，主要是副本的回放进度，即数据同步的进度。一般来说，Follower 的回放进度会略落后于 Leader，只要落后的幅度没有超过一个阈值，Leader 就会认为副本处于“健康”的状态，可以快速回放出 Leader 上的修改。Leader 认为某个副本在一定时间内“健康”后，会授予 Follower 一段时间的 Lease。通俗的说，Leader 在接下来的一段时间内“信任” Follower 会保持“健康”状态，并且可以提供强一致性读服务。在这个“信任”期内，Leader 的每一个复制表事务提交前都会确认 Follower 的回放进度。Follower 回放出本事务的修改后，Leader 才会汇报用户，事务提交成功。此时，用户在 Follower 上可以读到刚刚提交的事务的修改。

复制表功能在 OceanBase 数据库 V3.x 版本上就已经存在，而对于 V4.x 版本，由于 OceanBase 数据库的架构有了比较大的变化，V4.x 复制表为了适应单机日志流的新架构，构建了基于分区的可读版本号校验以及基于日志流的 Lease 授予机制，用于保证强一致性读的正确性。

另外，V4.x 版本的复制表功能完善了切主不 Kill 事务的能力，在用户或负载均衡发起 Leader 切换时，未提交的复制表事务不会像 V3.x 版本一样无法继续，而是可以在切主后继续执行。对比 V3.x 版本，V4.x 的复制表功能也有着更好的写事务性能和更强的容灾能力，副本宕机对于读操作的影响更低。

创建复制表的语法是在 `CREATE TABLE` 语句后增加 `DUPLICATE_SCOPE` 选项，仅用户租户可以创建复制表，`sys` 租户无法创建复制表。创建复制表的 SQL 语句如下：

```sql
CREATE TABLE table_name column_definition DUPLICATE_SCOPE='none | cluster';
```

其中，`DUPLICATE_SCOPE` 参数用来指定复制表的属性，取值如下：

* `none`：表示该表是一个普通表。
* `cluster`：表示该表是一个复制表，Leader 需要将事务复制到当前租户的所有 F 副本及 R 副本。

创建表时，如果不指定 `DUPLICATE_SCOPE`，则默认值为 `none`。

```sql
CREATE TABLE dup_t1 (c1 NUMBER,c2 NUMBER) DUPLICATE_SCOPE= 'cluster';
```

当某个租户的第一个复制表被创建时，系统会同时创建一个特殊的日志流——广播日志流。之后新建的复制表都会创建到广播日志流上。广播日志流与普通日志流的不同之处在于，广播日志流会自动地在租户内的每个 OBServer 节点上都部署一个副本，保证在理想情况下，复制表可以在任意一个 OBServer 节点上提供强一致性读。您可以通过以下 SQL 查看租户的复制表所在的广播日志流：

```sql
SELECT * FROM SYS.DBA_OB_LS WHERE flag LIKE "%DUPLICATE%";
```

查询结果的示例如下。

```shell
+-------+--------+--------------+---------------+-------------+---------------------+----------+---------------------+---------------------+-----------+
| LS_ID | STATUS | PRIMARY_ZONE | UNIT_GROUP_ID | LS_GROUP_ID | CREATE_SCN          | DROP_SCN | SYNC_SCN            | READABLE_SCN        | FLAG      |
+-------+--------+--------------+---------------+-------------+---------------------+----------+---------------------+---------------------+-----------+
|  1003 | NORMAL | z1;z2        |             0 |           0 | 1684982852976428261 |     NULL | 1684983282912048623 | 1684983282912048623 | DUPLICATE |
+-------+--------+--------------+---------------+-------------+---------------------+----------+---------------------+---------------------+-----------+
1 rows in set
```

示例中，`LS_ID` 为 `1003` 的日志流即为广播日志流，当前租户的所有复制表都创建在该日志流上。有关广播日志流的更多介绍，请参见 [副本介绍](../../../../600.manage/300.replica-management/100.replica-introduction.md)。

复制表创建成功后，可以与普通表一样进行插入和读写操作。不同的是，对于读请求，如果使用 Proxy 的方式连接数据库，则读请求可能会路由到任意一个 OBServer 节点执行；如果是通过直连方式连接数据库，则只要本地副本可读，系统就会在直连的 OBServer 节点上执行读请求。更多数据库连接方式的介绍，请参见 [连接方式概述](../../../../300.develop/100.application-development-of-mysql-mode/100.connect-to-oceanbase-database-of-mysql-mode/100.connection-methods-overview-of-mysql-mode.md)。

## 复制已有表的数据创建新表

通过 `CREATE TABLE AS SELECT` 语句复制表的基本数据类型和数据，但不包含约束、索引和非空等属性。

示例语句如下：

```sql
CREATE TABLE t2_copy AS SELECT * FROM t2;
```

不支持使用 `CREATE TABLE LIKE` 语句复制表结构。

## 创建表时标识 Skip Index 属性

Skip Index 是一种存储层执行计算优化方法，用于在分析型查询中通过存储数据块粒度的预聚合数据并参与到下推的计算表达式求值中，从而跳过一些不必要的 IO 与数据扫描，降低扫描过程中的开销。Skip Index 通过对索引树存储的元数据进行扩展，新增列级别的元数据字段，来对索引节点对应 Range 内指定列数据的最大值/最小值/null count/sum 等进行聚合并存储，在执行下压的表达式计算时通过索引上的聚合数据对数据进行动态剪裁来降低扫描过程中的开销。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>预聚合的本质在于将查询执行阶段的计算提前至数据导入阶段，通过增加额外的存储空间以提高查询效率。这种方法会导致 Compaction 进程产生额外的负担，并且增加存储资源的消耗。在特定的数据分布情况下，Skip Index 的效果可能会减弱，进而影响查询效率。</p>
</main>

Skip Index 是列的一种属性。在列存格式中，默认情况下，每一列都会尽可能添加 `skip_index(min_max，sum)` 属性，前提是列的数据类型满足相应的要求。如果数据类型不支持，则对应列不会具有此属性。当前的 Skip Index 属性主要针对行存格式，对列式存储格式暂时无效。此外，当通过 `DESC table_name` 或 `SHOW CREATE TABLE table_name` 命令查看表的列属性时，对于列式表，Skip Index 属性不会显示，只有用户显式设置的属性才会展示出来。

### Skip Index 的 DDL 行为

* Skip Index 数据的维护会在合并时在基线数据上完成，所有聚合数据更新的 DDL 动作目前都要依赖渐进合并。即 Skip Index 是可以部分生效，例如在某一列上新建一个 Skip Index，每当完成一次合并，被新写入的数据上的 Skip Index 都是生效的。当完成一轮全量合并后，所有数据被重写，则 Skip Index 对这一列所有数据都会生效。

* Skip Index 是一种可以通过 Online DDL 操作来应用的列属性。

* 一列所能拥有的 Skip Index 属性受该列数据类型和特征的限制。有级联关系的列会继承相应的聚合属性，例如索引列。

* 在为列添加 Skip Index 属性时，若发现单个表的 Skip Index 的大小可能会超出存储支持的最大限制，系统将报出错误。使用 Skip Index 是一种以空间换取时间的优化策略，因此在决定为特定列添加 Skip Index 属性时，需要确保此操作对查询性能有实际意义，以免浪费存储资源。

* 列存格式的列，当列类型符合要求时，默认会同时创建 `MIN_MAX` 和 `SUM` 聚合的 Skip Index。

#### Skip Index 使用限制

* JSON 和空间数据类型的列禁止创建 Skip Index。

* 对于非数值类型的列禁止创建 `SUM` 类型的 Skip Index。数值类型包括：整数类型、定点类型和浮点类型（Bit-Value 类型不支持）。

* 生成列禁止创建 Skip Index。

### 标识 Skip Index 方法

通过指定 `SKIP_INDEX(skip_index_option)` 标识列的 Skip Index 属性。`skip_index_option` 取值如下：

* `MIN_MAX`：是 Skip Index 中最通用的聚合数据类型，它会在索引节点粒度下存储被索引列的最大值、最小值和 Null Count。这种类型的数据可以加速普通比较计算。

* `SUM`：用于加速数值类型的 `SUM` 聚合的下推。

* `MIN_MAX, SUM`：同时使用 `MIN_MAX` 和 `SUM` 聚合的 Skip Index 类型。

有关 Skip Index 属性更改的信息请参见 [更改表](600.change-table-of-oracle-mode.md)。

#### 示例

建表时标识 Skip Index 属性。

```sql
CREATE TABLE test_skidx(
  col1 NUMBER SKIP_INDEX(MIN_MAX, SUM), 
  col2 FLOAT SKIP_INDEX(MIN_MAX), 
  col3 VARCHAR2(1024) SKIP_INDEX(MIN_MAX),
  col4 CHAR(10)
  );
```

## 创建列存表

OceanBase 数据库支持创建列存表、行存列存转换以及创建列存索引的功能。OceanBase 数据库默认建表时，构建的是行存表，通过设置 `WITH COLUMN GROUP` 选项可以显示指定为列存或者行存列存冗余状态。

有关行存列存转换的信息请参见 [更改表](600.change-table-of-oracle-mode.md)。有关创建列存索引的信息，请参见 [创建索引](../400.manage-indexes-of-oracle-mode/200.create-an-index-of-oracle-mode.md)。

通过指定 `WITH COLUMN GROUP(all columns, each column)` 创建行存列存冗余表。

**示例如下：**

```sql
CREATE TABLE tbl1_cg (col1 NUMBER PRIMARY KEY, col2 VARCHAR2(50)) WITH COLUMN GROUP(all columns, each column);
```

通过指定 `WITH COLUMN GROUP(each column)` 创建列存表。

**示例如下：**

```sql
CREATE TABLE tbl2_cg (col1 NUMBER PRIMARY KEY, col2 VARCHAR2(50)) WITH COLUMN GROUP(each column);
```

## 相关文档

* [CREATE TABLE](../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/2400.create-table-of-oracle-mode.md)

* [ALTER TABLE](../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1000.alter-table-of-oracle-mode.md)
