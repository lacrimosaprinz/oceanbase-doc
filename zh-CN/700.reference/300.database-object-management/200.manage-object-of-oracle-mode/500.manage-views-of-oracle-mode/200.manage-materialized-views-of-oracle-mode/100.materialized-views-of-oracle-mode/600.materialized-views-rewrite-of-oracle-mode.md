|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# 物化视图查询改写

通过使用物化视图来加速查询，当输入一个不使用物化视图的查询时，系统会自动将查询重写为使用现有物化视图的查询。该方法的原理是将查询语句与物化视图的定义进行匹配，如果发现匹配的物化视图，则自动将查询重写为使用物化视图的查询，这样可以大大提高查询性能和效率。

OceanBase 数据库当前版本的物化视图查询改写主要为了支持收藏夹的场景。

## 物化视图查询改写使用要求

* 物化视图满足以下要求：

  * 创建物化视图时，指定 `ENABLE QUERY REWRITE` 开启当前物化视图的自动改写。

    <main id="notice" type='notice'>
      <h4>注意</h4>
      <p>OceanBase 数据库 Oracle 模式下，创建支持改写的物化视图时必须指定刷新方式（<code>refresh_clause</code>）。</p>
    </main>

  * 需要物化视图仅包含 `SELECT JOIN` 与 `WHERE` 子句，即 SPJ 查询。对于不满足条件的物化视图，不会报错，但不会被用于改写。

* 当前查询满足以下要求：

  * 查询为 `SELECT` 查询，不是集合查询或层次查询，并且不包含窗口函数。
  * `FROM` 子句与物化视图完全匹配。
  * `WHERE` 条件物化视图是当前查询的子集，当前查询有聚合的情况下需要完全匹配。例如，物化视图的 `WHERE` 是 `c1 > 10`，当前查询的 `WHERE` 是 `c1 > 10 AND c2 >20`。这样物化视图的条件 {c1 > 10} 是当前查询 {c1>10, c2>20} 的子集。
  * `SELECT` 项、当前查询多余的 `WHERE`/`HAVING` 条件、`GROUP BY` 列等需要物化视图的 `SELECT` 中包含所需的列。

## 规则/代价检查

查询改写时，OceanBase 数据库当前版本不进行代价检查，但规则检查要求改写后的 `WHERE` 条件能够使用至少一个物化视图上的索引。此外，当前的改写机制仅支持前 10 个物化视图，超过 10 个物化视图将不会被匹配到适用的物化视图进行改写。

## 物化视图改写

控制物化视图查询改写的系统变量如下：

* `query_rewrite_enabled`：用于是否开启物化视图改写功能。该变量的详细介绍信息，参见 [query_rewrite_enabled](../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/11050.query_rewrite_enabled-global.md)。

    **示例如下：**

    ```sql
    SET query_rewrite_enabled = 'force';
    ```

* `query_rewrite_integrity`：用于指定物化视图改写的数据一致性检查级别。该变量的详细介绍信息，参见 [query_rewrite_integrity](../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/11060.query_rewrite_integrity-global.md)。

    **示例如下：**

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

**通过以下示例展示物化视图改写：**

1. 创建表 `test_tbl1`。

    ```sql
    CREATE TABLE test_tbl1 (col1 INT, col2 INT, col3 INT);
    ```

2. 创建表 `test_tbl2`。

    ```sql
    CREATE TABLE test_tbl2 (col1 INT, col2 INT, col3 INT);
    ```

3. 创建名为 `mv_test_tbl1_tbl2` 的物化视图，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv_test_tbl1_tbl2
        NEVER REFRESH
        ENABLE QUERY REWRITE
        AS SELECT t1.col1 col1, t1.col2 t1col2, t1.col3 t1col3, t2.col2 t2col2, t2.col3 t2col3 
        FROM test_tbl1 t1, test_tbl2 t2
        WHERE t1.col1 = t2.col1;
    ```

4. 当输入查询 `SELECT count(*), test_tbl1.col1 col1 FROM test_tbl1, test_tbl2 WHERE test_tbl1.col1 = test_tbl2.col1 AND test_tbl2.col2 > 10 GROUP BY test_tbl1.col1;` 时，发生物化视图查询改写。

    ```sql
    SELECT count(*), test_tbl1.col1 col1 FROM test_tbl1, test_tbl2 WHERE test_tbl1.col1 = test_tbl2.col1 AND test_tbl2.col2 > 10 GROUP BY test_tbl1.col1;

    MV REWRITE ==>

    SELECT count(*), mv_test_tbl1_tbl2.col1 col1 FROM mv_test_tbl1_tbl2 WHERE mv_test_tbl1_tbl2.t2col2 > 10 GROUP BY mv_test_tbl1_tbl2.col1;
    ```

    物化视图查询改写要求输入的查询与物化视图的 `FROM` 完全匹配，`WHERE` 条件包含物化视图中的所有 `WHERE` 条件。

## 物化视图查询改写控制

物化视图查询改写控制包括 `MV_REWRITE`、`NO_MV_REWRITE` 两个 Hint，并且这两个 Hint 的优先级高于系统变量 `query_rewrite_enabled`。

### MV_REWRITE

`MV_REWRITE` 语法如下：

```sql
/*+ MV_REWRITE (@ queryblock [mv_name_list]) */

mv_name_list:
    mv_name [, mv_name ...]
```

单独使用 `MV_REWRITE` Hint 时可以跳过物化视图查询改写的规则/代价检查，直接使用可以使用的改写。Hint 后指定一个或多个物化视图的情况，除了跳过规则/代价检查外，物化视图查询改写将只使用指定的物化视图尝试改写，忽略所有没被指定的物化视图。

使用 `MV_REWRITE` Hint 指定物化视图时，无法强制使用没有 `ENABLE QUERY REWRITE`（开启当前物化视图的自动改写） 子句的物化视图，无法在系统变量 `query_rewrite_integrity` 设置为 `enforced` 的情况下强制使用非实时物化视图。

### NO_MV_REWRITE

`NO_MV_REWRITE` 语法如下：

```sql
/*+ NO_MV_REWRITE (@ queryblock) */
```

禁止物化视图查询改写，可以指定 query block。

### 物化视图查询改写控制 Hint 使用示例

1. 创建基表 `tbl2`。

    ```sql
    CREATE TABLE tbl2 (col1 INT, col2 INT);
    ```

2. 向基表 `tbl2` 中插入两条数据。

    ```sql
    INSERT INTO tbl2 VALUES (1,2),(3,4);
    ```

    返回结果如下：

    ```shell
    Query OK, 2 rows affected
    Records: 2  Duplicates: 0  Warnings: 0
    ```

3. 创建物化视图 `mv1_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv1_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2;
    ```

4. 创建物化视图 `mv2_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv2_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2 WHERE tbl2.col1 > 1;
    ```

5. 设置系统变量 `query_rewrite_integrity` 为 `stale_tolerated`。

    <main id="notice" type='explain'>
      <h4>说明</h4>
      <p><code>MV_REWRITE</code> 和 <code>NO_MV_REWRITE</code> Hint 的优先级高于系统变量 <code>query_rewrite_enabled</code>，因此不需要设置 <code>query_rewrite_enabled</code>。但是需要设置 <code>query_rewrite_integrity</code> 为 <code>stale_tolerated</code> 才可以使用非实时物化视图进行改写。</p>
    </main>

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

6. 使用 `MV_REWRITE` Hint 用物化视图尝试进行改写，并跳过改写代价/规则检查。下面两条查询都将使用物化视图 `mv1_tbl2` 进行改写。

   * `/*+mv_rewrite*/` 将尝试使用所有符合改写条件的物化视图进行改写，一旦找到了符合改写要求的物化视图，后续的物化视图将不再被考虑，并跳过改写代价/规则检查。

       ```sql
       EXPLAIN SELECT /*+mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
       ```

       返回结果如下：

       ```shell
       +----------------------------------------------------------------------------------------------+
       | Query Plan                                                                                   |
       +----------------------------------------------------------------------------------------------+
       | =====================================================                                        |
       | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                                        |
       | -----------------------------------------------------                                        |
       | |0 |HASH GROUP BY    |        |1       |3           |                                        |
       | |1 |└─TABLE FULL SCAN|MV1_TBL2|1       |3           |                                        |
       | =====================================================                                        |
       | Outputs & filters:                                                                           |
       | -------------------------------------                                                        |
       |   0 - output([T_FUN_COUNT(*)], [MV1_TBL2.COL1]), filter(nil), rowset=16                      |
       |       group([MV1_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                     |
       |   1 - output([MV1_TBL2.COL1]), filter([MV1_TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
       |       access([MV1_TBL2.COL1]), partitions(p0)                                                |
       |       is_index_back=false, is_global_index=false, filter_before_indexback[false],            |
       |       range_key([MV1_TBL2.__pk_increment]), range(MIN ; MAX)always true                      |
       +----------------------------------------------------------------------------------------------+
       14 rows in set
       ```

   * `/*+mv_rewrite(mv1_tbl2)*/` 将尝试使用 `mv2_tbl2` 进行改写，并跳过改写代价/规则检查。

        ```sql
        EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
        ```

        返回结果如下：

        ```shell
        +-------------------------------------------------------------------------+
        | Query Plan                                                              |
        +-------------------------------------------------------------------------+
        | =====================================================                   |
        | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                   |
        | -----------------------------------------------------                   |
        | |0 |HASH GROUP BY    |        |1       |3           |                   |
        | |1 |└─TABLE FULL SCAN|MV2_TBL2|1       |3           |                   |
        | =====================================================                   |
        | Outputs & filters:                                                      |
        | -------------------------------------                                   |
        |   0 - output([T_FUN_COUNT(*)], [MV2_TBL2.COL1]), filter(nil), rowset=16 |
        |       group([MV2_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                |
        |   1 - output([MV2_TBL2.COL1]), filter(nil), rowset=16                   |
        |       access([MV2_TBL2.COL1]), partitions(p0)                           |
        |       is_index_back=false, is_global_index=false,                       |
        |       range_key([MV2_TBL2.__pk_increment]), range(MIN ; MAX)always true |
        +-------------------------------------------------------------------------+
        14 rows in set
        ```

7. 由于 `mv2_tbl2` 无法用于下面查询的改写（`WHERE` 条件不满足），下面的查询只尝试使用 `mv2_tbl2`，因此无法使用其他物化视图查询改写，不会进行物化视图查询改写。

    ```sql
    EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 < 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +--------------------------------------------------------------------------------------+
    | Query Plan                                                                           |
    +--------------------------------------------------------------------------------------+
    | =================================================                                    |
    | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                    |
    | -------------------------------------------------                                    |
    | |0 |HASH GROUP BY    |    |1       |3           |                                    |
    | |1 |└─TABLE FULL SCAN|TBL2|1       |3           |                                    |
    | =================================================                                    |
    | Outputs & filters:                                                                   |
    | -------------------------------------                                                |
    |   0 - output([T_FUN_COUNT(*)], [TBL2.COL1]), filter(nil), rowset=16                  |
    |       group([TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                 |
    |   1 - output([TBL2.COL1]), filter([TBL2.COL1 < cast(1, NUMBER(-1, -85))]), rowset=16 |
    |       access([TBL2.COL1]), partitions(p0)                                            |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],    |
    |       range_key([TBL2.__pk_increment]), range(MIN ; MAX)always true                  |
    +--------------------------------------------------------------------------------------+
    14 rows in set
    ```

8. 使用 `/*+ no_mv_rewrite*/` Hint，不会进行物化视图查询改写。

    ```sql
    EXPLAIN SELECT /*+no_mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +--------------------------------------------------------------------------------------+
    | Query Plan                                                                           |
    +--------------------------------------------------------------------------------------+
    | =================================================                                    |
    | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                    |
    | -------------------------------------------------                                    |
    | |0 |HASH GROUP BY    |    |1       |3           |                                    |
    | |1 |└─TABLE FULL SCAN|TBL2|1       |3           |                                    |
    | =================================================                                    |
    | Outputs & filters:                                                                   |
    | -------------------------------------                                                |
    |   0 - output([T_FUN_COUNT(*)], [TBL2.COL1]), filter(nil), rowset=16                  |
    |       group([TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                 |
    |   1 - output([TBL2.COL1]), filter([TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
    |       access([TBL2.COL1]), partitions(p0)                                            |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],    |
    |       range_key([TBL2.__pk_increment]), range(MIN ; MAX)always true                  |
    +--------------------------------------------------------------------------------------+
    14 rows in set
    ```

## 收藏夹物化视图查询改写示例

1. 修改控制物化视图查询改写的系统变量的值。

    ```sql
    SET query_rewrite_enabled = 'true';
    ```

    ```sql
    SET query_rewrite_integrity = 'enforced';
    ```

2. 创建基表 `collect_info` 和 `collect_item`。

    ```sql
    CREATE TABLE collect_info(user_id INT,
        item_id INT,
        user_name VARCHAR2(1000),
        PRIMARY KEY(user_id, item_id)
        ) PARTITION BY HASH(user_id) PARTITIONS 16;
    ```

    ```sql
    CREATE TABLE collect_item(item_id INT,
        item_type INT,
        price INT,
        pic_url VARCHAR2(1000),
        PRIMARY KEY(item_id)
        ) PARTITION BY HASH(item_id) PARTITIONS 16;
    ```

3. 在表 `collect_info` 和表 `collect_item` 上创建物化视图日志。

    ```sql
    CREATE MATERIALIZED VIEW LOG ON collect_info WITH PRIMARY KEY, ROWID, SEQUENCE (user_name) INCLUDING NEW VALUES;
    ```

    ```sql
    CREATE MATERIALIZED VIEW LOG ON collect_item WITH PRIMARY KEY, ROWID, SEQUENCE (item_type, price, pic_url) INCLUDING NEW VALUES;
    ```

4. 创建实时物化视图 `collect_mv`。

    ```sql
    CREATE MATERIALIZED VIEW collect_mv
        NEVER REFRESH
        ENABLE ON QUERY COMPUTATION
        ENABLE QUERY REWRITE
        AS SELECT collect_info.user_id mv_uid,
                collect_info.item_id uiid,
                collect_item.item_id iid,
                collect_item.item_type itype,
                collect_item.price price,
                collect_item.pic_url pic
            FROM collect_info, collect_item
            WHERE collect_info.item_id = collect_item.item_id;
    ```

5. 在物化视图 `collect_mv` 上创建索引 `idx_collect_mv`。

    ```sql
    CREATE INDEX idx_collect_mv ON collect_mv(mv_uid);
    ```

6. SPJ 查询：查询 `collect_info` 表的 `user_id` 字段以及 `collect_item` 表的所有列的数据。接下来，对两个表进行连接操作，使用 `WHERE` 子句中的条件 `collect_info.item_id = collect_item.item_id` 进行匹配。然后，系统会对连接的结果进行进一步筛选，以筛选出满足 `user_id = 10000` 的行。

    ```sql
    EXPLAIN SELECT collect_info.user_id, collect_item.*
        FROM collect_info, collect_item
        WHERE collect_info.item_id = collect_item.item_id
            AND collect_info.user_id = 10000;
    ```

    返回结果如下：

    ```shell
    +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Query Plan                                                                                                                                                                    |
    +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | =============================================================================================                                                                                 |
    | |ID|OPERATOR                               |NAME                      |EST.ROWS|EST.TIME(us)|                                                                                 |
    | ---------------------------------------------------------------------------------------------                                                                                 |
    | |0 |UNION ALL                              |                          |2       |131         |                                                                                 |
    | |1 |├─PX COORDINATOR                       |                          |1       |29          |                                                                                 |
    | |2 |│ └─EXCHANGE OUT DISTR                 |:EX10001                  |1       |29          |                                                                                 |
    | |3 |│   └─NESTED-LOOP ANTI JOIN            |                          |1       |29          |                                                                                 |
    | |4 |│     ├─EXCHANGE IN DISTR              |                          |1       |10          |                                                                                 |
    | |5 |│     │ └─EXCHANGE OUT DISTR (PKEY)    |:EX10000                  |1       |10          |                                                                                 |
    | |6 |│     │   └─HASH RIGHT ANTI JOIN       |                          |1       |10          |                                                                                 |
    | |7 |│     │     ├─SUBPLAN SCAN             |VIEW1                     |1       |3           |                                                                                 |
    | |8 |│     │     │ └─TABLE RANGE SCAN       |MLOG$_COLLECT_INFO        |1       |3           |                                                                                 |
    | |9 |│     │     └─TABLE RANGE SCAN         |COLLECT_MV(IDX_COLLECT_MV)|1       |8           |                                                                                 |
    | |10|│     └─SUBPLAN SCAN                   |VIEW2                     |1       |287         |                                                                                 |
    | |11|│       └─PX PARTITION ITERATOR        |                          |1       |287         |                                                                                 |
    | |12|│         └─TABLE RANGE SCAN           |MLOG$_COLLECT_ITEM        |1       |287         |                                                                                 |
    | |13|├─HASH JOIN                            |                          |1       |43          |                                                                                 |
    | |14|│ ├─TABLE RANGE SCAN                   |COLLECT_INFO              |1       |3           |                                                                                 |
    | |15|│ └─PX COORDINATOR                     |                          |1       |40          |                                                                                 |
    | |16|│   └─EXCHANGE OUT DISTR               |:EX20001                  |1       |40          |                                                                                 |
    | |17|│     └─NESTED-LOOP ANTI JOIN          |                          |1       |40          |                                                                                 |
    | |18|│       ├─NESTED-LOOP JOIN             |                          |1       |22          |                                                                                 |
    | |19|│       │ ├─EXCHANGE IN DISTR          |                          |1       |3           |                                                                                 |
    | |20|│       │ │ └─EXCHANGE OUT DISTR (PKEY)|:EX20000                  |1       |3           |                                                                                 |
    | |21|│       │ │   └─SUBPLAN SCAN           |VIEW6                     |1       |3           |                                                                                 |
    | |22|│       │ │     └─MERGE DISTINCT       |                          |1       |3           |                                                                                 |
    | |23|│       │ │       └─SUBPLAN SCAN       |VIEW3                     |1       |3           |                                                                                 |
    | |24|│       │ │         └─TABLE RANGE SCAN |MLOG$_COLLECT_INFO        |1       |3           |                                                                                 |
    | |25|│       │ └─PX PARTITION ITERATOR      |                          |1       |287         |                                                                                 |
    | |26|│       │   └─TABLE GET                |COLLECT_ITEM              |1       |287         |                                                                                 |
    | |27|│       └─SUBPLAN SCAN                 |VIEW4                     |1       |287         |                                                                                 |
    | |28|│         └─PX PARTITION ITERATOR      |                          |1       |287         |                                                                                 |
    | |29|│           └─TABLE RANGE SCAN         |MLOG$_COLLECT_ITEM        |1       |287         |                                                                                 |
    | |30|└─PX COORDINATOR                       |                          |1       |61          |                                                                                 |
    | |31|  └─EXCHANGE OUT DISTR                 |:EX30001                  |1       |59          |                                                                                 |
    | |32|    └─HASH JOIN                        |                          |1       |55          |                                                                                 |
    | |33|      ├─EXCHANGE IN DISTR              |                          |1       |5           |                                                                                 |
    | |34|      │ └─EXCHANGE OUT DISTR (PKEY)    |:EX30000                  |1       |4           |                                                                                 |
    | |35|      │   └─TABLE RANGE SCAN           |COLLECT_INFO              |1       |3           |                                                                                 |
    | |36|      └─PX PARTITION ITERATOR          |                          |1       |50          |                                                                                 |
    | |37|        └─NESTED-LOOP JOIN             |                          |1       |50          |                                                                                 |
    | |38|          ├─SUBPLAN SCAN               |VIEW7                     |1       |34          |                                                                                 |
    | |39|          │ └─MERGE DISTINCT           |                          |1       |34          |                                                                                 |
    | |40|          │   └─SUBPLAN SCAN           |VIEW5                     |1       |34          |                                                                                 |
    | |41|          │     └─TABLE FULL SCAN      |MLOG$_COLLECT_ITEM        |1       |34          |                                                                                 |
    | |42|          └─TABLE GET                  |COLLECT_ITEM              |1       |246         |                                                                                 |
    | =============================================================================================                                                                                 |
    | Outputs & filters:                                                                                                                                                            |
    | -------------------------------------                                                                                                                                         |
    |   0 - output([UNION([1])], [UNION([2])], [UNION([3])], [UNION([4])], [UNION([5])]), filter(nil), rowset=16                                                                    |
    |   1 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), filter(nil), rowset=16                                         |
    |   2 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), filter(nil), rowset=16                                         |
    |       dop=1                                                                                                                                                                   |
    |   3 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), filter(nil), rowset=16                                         |
    |       conds(nil), nl_params_([COLLECT_MV.IID(:1)]), use_batch=false                                                                                                           |
    |   4 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC], [PARTITION_ID]), filter(nil), rowset=16                         |
    |   5 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC], [PARTITION_ID]), filter(nil), rowset=16                         |
    |       (#keys=1, [COLLECT_MV.IID]), is_single, dop=1                                                                                                                           |
    |   6 - output([COLLECT_MV.MV_UID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), filter(nil), rowset=16                                         |
    |       equal_conds([COLLECT_MV.UIID = VIEW1.MLOG$_COLLECT_INFO.ITEM_ID]), other_conds(nil)                                                                                     |
    |   7 - output([VIEW1.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                                      |
    |       access([VIEW1.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                                              |
    |   8 - output([MLOG$_COLLECT_INFO.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                                                  |
    |       access([MLOG$_COLLECT_INFO.ITEM_ID], [ORA_ROWSCN]), partitions(p13)                                                                                                     |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                             |
    |       range_key([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [MLOG$_COLLECT_INFO.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),                           |
    |       range_cond([cast(10000, NUMBER(-1, -85)) = MLOG$_COLLECT_INFO.USER_ID])                                                                                                 |
    |   9 - output([COLLECT_MV.MV_UID], [COLLECT_MV.UIID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), filter(nil), rowset=16                      |
    |       access([COLLECT_MV.__pk_increment], [COLLECT_MV.MV_UID], [COLLECT_MV.UIID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE], [COLLECT_MV.PRICE], [COLLECT_MV.PIC]), partitions(p0) |
    |       is_index_back=true, is_global_index=false,                                                                                                                              |
    |       range_key([COLLECT_MV.MV_UID], [COLLECT_MV.__pk_increment]), range(10000,MIN ; 10000,MAX),                                                                              |
    |       range_cond([COLLECT_MV.MV_UID = cast(10000, NUMBER(-1, -85))])                                                                                                          |
    |  10 - output(nil), filter(nil), rowset=16                                                                                                                                     |
    |       access(nil)                                                                                                                                                             |
    |  11 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                                            |
    |       affinitize, force partition granule                                                                                                                                     |
    |  12 - output([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                                    |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                                                 |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                             |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                                          |
    |       range_cond([:1 = MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                                           |
    |  13 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                  |
    |       equal_conds([COLLECT_INFO.ITEM_ID = COLLECT_ITEM.ITEM_ID]), other_conds(nil)                                                                                            |
    |  14 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                          |
    |       access([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), partitions(p13)                                                                                                 |
    |       is_index_back=false, is_global_index=false,                                                                                                                             |
    |       range_key([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), range(10000,MIN ; 10000,MAX),                                                                                |
    |       range_cond([COLLECT_INFO.USER_ID = cast(10000, NUMBER(-1, -85))])                                                                                                       |
    |  15 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |  16 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       dop=1                                                                                                                                                                   |
    |  17 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       conds(nil), nl_params_([COLLECT_ITEM.ITEM_ID(:8)]), use_batch=false                                                                                                     |
    |  18 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       conds(nil), nl_params_([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID(:7)]), use_batch=false                                                                                   |
    |  19 - output([PARTITION_ID], [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                |
    |  20 - output([PARTITION_ID], [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                |
    |       (#keys=1, [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), is_single, dop=1                                                                                                   |
    |  21 - output([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                                |
    |       access([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                                        |
    |  22 - output([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                  |
    |       distinct([VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                                            |
    |  23 - output([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                  |
    |       access([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                          |
    |  24 - output([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                    |
    |       access([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [ORA_ROWSCN]), partitions(p13)                                                                       |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                             |
    |       range_key([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [MLOG$_COLLECT_INFO.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),                           |
    |       range_cond([cast(10000, NUMBER(-1, -85)) = MLOG$_COLLECT_INFO.USER_ID])                                                                                                 |
    |  25 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       affinitize, partition wise, force partition granule                                                                                                                     |
    |  26 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       access([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), partitions(p[0-15])                                             |
    |       is_index_back=false, is_global_index=false,                                                                                                                             |
    |       range_key([COLLECT_ITEM.ITEM_ID]), range(MIN ; MAX),                                                                                                                    |
    |       range_cond([COLLECT_ITEM.ITEM_ID = :7])                                                                                                                                 |
    |  27 - output(nil), filter(nil), rowset=16                                                                                                                                     |
    |       access(nil)                                                                                                                                                             |
    |  28 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                                            |
    |       affinitize, partition wise, force partition granule                                                                                                                     |
    |  29 - output([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                                    |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                                                 |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                             |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                                          |
    |       range_cond([:8 = MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                                           |
    |  30 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                  |
    |  31 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                  |
    |       dop=1                                                                                                                                                                   |
    |  32 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                  |
    |       equal_conds([COLLECT_INFO.ITEM_ID = COLLECT_ITEM.ITEM_ID]), other_conds(nil)                                                                                            |
    |  33 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                          |
    |  34 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                          |
    |       (#keys=1, [COLLECT_INFO.ITEM_ID]), is_single, dop=1                                                                                                                     |
    |  35 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                          |
    |       access([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), partitions(p13)                                                                                                 |
    |       is_index_back=false, is_global_index=false,                                                                                                                             |
    |       range_key([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), range(10000,MIN ; 10000,MAX),                                                                                |
    |       range_cond([COLLECT_INFO.USER_ID = cast(10000, NUMBER(-1, -85))])                                                                                                       |
    |  36 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       affinitize, partition wise, force partition granule                                                                                                                     |
    |  37 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       conds(nil), nl_params_([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID(:14)]), use_batch=false                                                                                  |
    |  38 - output([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                                |
    |       access([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                                        |
    |  39 - output([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                                      |
    |       distinct([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                                            |
    |  40 - output([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                                      |
    |       access([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                                              |
    |  41 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                                                  |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                                                 |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                                             |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true                                                           |
    |  42 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), filter(nil), rowset=16                                          |
    |       access([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.PRICE], [COLLECT_ITEM.PIC_URL]), partitions(p[0-15])                                             |
    |       is_index_back=false, is_global_index=false,                                                                                                                             |
    |       range_key([COLLECT_ITEM.ITEM_ID]), range(MIN ; MAX),                                                                                                                    |
    |       range_cond([COLLECT_ITEM.ITEM_ID = :14])                                                                                                                                |
    +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
    157 rows in set
    ```

7. 带有聚合的查询：对 `collect_info` 和 `collect_item` 两个表进行连接，并通过 `collect_info.item_id = collect_item.item_id` 条件进行匹配。然后，使用 `collect_info.user_id = 10000` 进一步筛选数据。接下来，对符合条件的数据进行分组操作。使用 `collect_info.user_id` 和 `collect_item.item_type` 作为分组依据，将数据分组为多个组，每个组由具有相同 `user_id` 和 `item_type` 的行组成。最后，在每个分组上应用聚合函数 `count(1)`，对每个组中的行进行计数。

    ```sql
    EXPLAIN SELECT collect_info.user_id, collect_item.item_type, count(1)
        FROM collect_info, collect_item
        WHERE collect_info.item_id = collect_item.item_id
            AND collect_info.user_id = 10000
        GROUP BY collect_info.user_id, collect_item.item_type;
    ```

    返回结果如下：

    ```shell
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | Query Plan                                                                                                                                                 |
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    | =================================================================================================                                                          |
    | |ID|OPERATOR                                   |NAME                      |EST.ROWS|EST.TIME(us)|                                                          |
    | -------------------------------------------------------------------------------------------------                                                          |
    | |0 |HASH GROUP BY                              |                          |1       |127         |                                                          |
    | |1 |└─SUBPLAN SCAN                             |RT_COLLECT_MV             |2       |127         |                                                          |
    | |2 |  └─UNION ALL                              |                          |2       |127         |                                                          |
    | |3 |    ├─PX COORDINATOR                       |                          |1       |28          |                                                          |
    | |4 |    │ └─EXCHANGE OUT DISTR                 |:EX10001                  |1       |28          |                                                          |
    | |5 |    │   └─NESTED-LOOP ANTI JOIN            |                          |1       |28          |                                                          |
    | |6 |    │     ├─EXCHANGE IN DISTR              |                          |1       |10          |                                                          |
    | |7 |    │     │ └─EXCHANGE OUT DISTR (PKEY)    |:EX10000                  |1       |10          |                                                          |
    | |8 |    │     │   └─HASH RIGHT ANTI JOIN       |                          |1       |10          |                                                          |
    | |9 |    │     │     ├─SUBPLAN SCAN             |VIEW1                     |1       |3           |                                                          |
    | |10|    │     │     │ └─TABLE RANGE SCAN       |MLOG$_COLLECT_INFO        |1       |3           |                                                          |
    | |11|    │     │     └─TABLE RANGE SCAN         |COLLECT_MV(IDX_COLLECT_MV)|1       |7           |                                                          |
    | |12|    │     └─SUBPLAN SCAN                   |VIEW2                     |1       |287         |                                                          |
    | |13|    │       └─PX PARTITION ITERATOR        |                          |1       |287         |                                                          |
    | |14|    │         └─TABLE RANGE SCAN           |MLOG$_COLLECT_ITEM        |1       |287         |                                                          |
    | |15|    ├─HASH JOIN                            |                          |1       |43          |                                                          |
    | |16|    │ ├─TABLE RANGE SCAN                   |COLLECT_INFO              |1       |3           |                                                          |
    | |17|    │ └─PX COORDINATOR                     |                          |1       |40          |                                                          |
    | |18|    │   └─EXCHANGE OUT DISTR               |:EX20001                  |1       |40          |                                                          |
    | |19|    │     └─NESTED-LOOP ANTI JOIN          |                          |1       |40          |                                                          |
    | |20|    │       ├─NESTED-LOOP JOIN             |                          |1       |22          |                                                          |
    | |21|    │       │ ├─EXCHANGE IN DISTR          |                          |1       |3           |                                                          |
    | |22|    │       │ │ └─EXCHANGE OUT DISTR (PKEY)|:EX20000                  |1       |3           |                                                          |
    | |23|    │       │ │   └─SUBPLAN SCAN           |VIEW6                     |1       |3           |                                                          |
    | |24|    │       │ │     └─MERGE DISTINCT       |                          |1       |3           |                                                          |
    | |25|    │       │ │       └─SUBPLAN SCAN       |VIEW3                     |1       |3           |                                                          |
    | |26|    │       │ │         └─TABLE RANGE SCAN |MLOG$_COLLECT_INFO        |1       |3           |                                                          |
    | |27|    │       │ └─PX PARTITION ITERATOR      |                          |1       |287         |                                                          |
    | |28|    │       │   └─TABLE GET                |COLLECT_ITEM              |1       |287         |                                                          |
    | |29|    │       └─SUBPLAN SCAN                 |VIEW4                     |1       |287         |                                                          |
    | |30|    │         └─PX PARTITION ITERATOR      |                          |1       |287         |                                                          |
    | |31|    │           └─TABLE RANGE SCAN         |MLOG$_COLLECT_ITEM        |1       |287         |                                                          |
    | |32|    └─PX COORDINATOR                       |                          |1       |57          |                                                          |
    | |33|      └─EXCHANGE OUT DISTR                 |:EX30001                  |1       |56          |                                                          |
    | |34|        └─HASH JOIN                        |                          |1       |55          |                                                          |
    | |35|          ├─PX PARTITION ITERATOR          |                          |1       |50          |                                                          |
    | |36|          │ └─NESTED-LOOP JOIN             |                          |1       |50          |                                                          |
    | |37|          │   ├─SUBPLAN SCAN               |VIEW7                     |1       |34          |                                                          |
    | |38|          │   │ └─MERGE DISTINCT           |                          |1       |34          |                                                          |
    | |39|          │   │   └─SUBPLAN SCAN           |VIEW5                     |1       |34          |                                                          |
    | |40|          │   │     └─TABLE FULL SCAN      |MLOG$_COLLECT_ITEM        |1       |34          |                                                          |
    | |41|          │   └─TABLE GET                  |COLLECT_ITEM              |1       |246         |                                                          |
    | |42|          └─EXCHANGE IN DISTR              |                          |1       |5           |                                                          |
    | |43|            └─EXCHANGE OUT DISTR (PKEY)    |:EX30000                  |1       |4           |                                                          |
    | |44|              └─TABLE RANGE SCAN           |COLLECT_INFO              |1       |3           |                                                          |
    | =================================================================================================                                                          |
    | Outputs & filters:                                                                                                                                         |
    | -------------------------------------                                                                                                                      |
    |   0 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE], [T_FUN_COUNT(*)]), filter(nil), rowset=16                                                            |
    |       group([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE]), agg_func([T_FUN_COUNT(*)])                                                                           |
    |   1 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE]), filter(nil), rowset=16                                                                              |
    |       access([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE])                                                                                                      |
    |   2 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16                                                                                           |
    |   3 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE]), filter(nil), rowset=16                                                                              |
    |   4 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE]), filter(nil), rowset=16                                                                              |
    |       dop=1                                                                                                                                                |
    |   5 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE]), filter(nil), rowset=16                                                                              |
    |       conds(nil), nl_params_([COLLECT_MV.IID(:1)]), use_batch=false                                                                                        |
    |   6 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE], [PARTITION_ID], [COLLECT_MV.IID]), filter(nil), rowset=16                                            |
    |   7 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE], [PARTITION_ID], [COLLECT_MV.IID]), filter(nil), rowset=16                                            |
    |       (#keys=1, [COLLECT_MV.IID]), is_single, dop=1                                                                                                        |
    |   8 - output([COLLECT_MV.MV_UID], [COLLECT_MV.ITYPE], [COLLECT_MV.IID]), filter(nil), rowset=16                                                            |
    |       equal_conds([COLLECT_MV.UIID = VIEW1.MLOG$_COLLECT_INFO.ITEM_ID]), other_conds(nil)                                                                  |
    |   9 - output([VIEW1.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                                   |
    |       access([VIEW1.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                           |
    |  10 - output([MLOG$_COLLECT_INFO.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                               |
    |       access([MLOG$_COLLECT_INFO.ITEM_ID], [ORA_ROWSCN]), partitions(p13)                                                                                  |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                          |
    |       range_key([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [MLOG$_COLLECT_INFO.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),        |
    |       range_cond([cast(10000, NUMBER(-1, -85)) = MLOG$_COLLECT_INFO.USER_ID])                                                                              |
    |  11 - output([COLLECT_MV.MV_UID], [COLLECT_MV.UIID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE]), filter(nil), rowset=16                                         |
    |       access([COLLECT_MV.__pk_increment], [COLLECT_MV.MV_UID], [COLLECT_MV.UIID], [COLLECT_MV.IID], [COLLECT_MV.ITYPE]), partitions(p0)                    |
    |       is_index_back=true, is_global_index=false,                                                                                                           |
    |       range_key([COLLECT_MV.MV_UID], [COLLECT_MV.__pk_increment]), range(10000,MIN ; 10000,MAX),                                                           |
    |       range_cond([COLLECT_MV.MV_UID = cast(10000, NUMBER(-1, -85))])                                                                                       |
    |  12 - output(nil), filter(nil), rowset=16                                                                                                                  |
    |       access(nil)                                                                                                                                          |
    |  13 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                         |
    |       affinitize, force partition granule                                                                                                                  |
    |  14 - output([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                 |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                          |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                       |
    |       range_cond([:1 = MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                        |
    |  15 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       equal_conds([COLLECT_INFO.ITEM_ID = COLLECT_ITEM.ITEM_ID]), other_conds(nil)                                                                         |
    |  16 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                       |
    |       access([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), partitions(p13)                                                                              |
    |       is_index_back=false, is_global_index=false,                                                                                                          |
    |       range_key([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), range(10000,MIN ; 10000,MAX),                                                             |
    |       range_cond([COLLECT_INFO.USER_ID = cast(10000, NUMBER(-1, -85))])                                                                                    |
    |  17 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |  18 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |       dop=1                                                                                                                                                |
    |  19 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |       conds(nil), nl_params_([COLLECT_ITEM.ITEM_ID(:8)]), use_batch=false                                                                                  |
    |  20 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |       conds(nil), nl_params_([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID(:7)]), use_batch=false                                                                |
    |  21 - output([PARTITION_ID], [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                             |
    |  22 - output([PARTITION_ID], [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                             |
    |       (#keys=1, [VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), is_single, dop=1                                                                                |
    |  23 - output([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                             |
    |       access([VIEW6.VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                     |
    |  24 - output([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                               |
    |       distinct([VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                                                         |
    |  25 - output([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                               |
    |       access([VIEW3.MLOG$_COLLECT_INFO.USER_ID], [VIEW3.MLOG$_COLLECT_INFO.ITEM_ID])                                                                       |
    |  26 - output([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16 |
    |       access([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [ORA_ROWSCN]), partitions(p13)                                                    |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                          |
    |       range_key([MLOG$_COLLECT_INFO.USER_ID], [MLOG$_COLLECT_INFO.ITEM_ID], [MLOG$_COLLECT_INFO.SEQUENCE$$]), range(10000,MIN,MIN ; 10000,MAX,MAX),        |
    |       range_cond([cast(10000, NUMBER(-1, -85)) = MLOG$_COLLECT_INFO.USER_ID])                                                                              |
    |  27 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       affinitize, partition wise, force partition granule                                                                                                  |
    |  28 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       access([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE]), partitions(p[0-15])                                                                        |
    |       is_index_back=false, is_global_index=false,                                                                                                          |
    |       range_key([COLLECT_ITEM.ITEM_ID]), range(MIN ; MAX),                                                                                                 |
    |       range_cond([COLLECT_ITEM.ITEM_ID = :7])                                                                                                              |
    |  29 - output(nil), filter(nil), rowset=16                                                                                                                  |
    |       access(nil)                                                                                                                                          |
    |  30 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                         |
    |       affinitize, partition wise, force partition granule                                                                                                  |
    |  31 - output([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                 |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                          |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true,                                       |
    |       range_cond([:8 = MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                        |
    |  32 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |  33 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       dop=1                                                                                                                                                |
    |  34 - output([COLLECT_INFO.USER_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       equal_conds([COLLECT_INFO.ITEM_ID = COLLECT_ITEM.ITEM_ID]), other_conds(nil)                                                                         |
    |  35 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |       affinitize, partition wise, force partition granule                                                                                                  |
    |  36 - output([COLLECT_ITEM.ITEM_TYPE], [COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                     |
    |       conds(nil), nl_params_([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID(:14)]), use_batch=false                                                               |
    |  37 - output([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                             |
    |       access([VIEW7.VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                     |
    |  38 - output([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                   |
    |       distinct([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                         |
    |  39 - output([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID]), filter(nil), rowset=16                                                                                   |
    |       access([VIEW5.MLOG$_COLLECT_ITEM.ITEM_ID])                                                                                                           |
    |  40 - output([MLOG$_COLLECT_ITEM.ITEM_ID]), filter([cast(ORA_ROWSCN, NUMBER(-1, -1)) > last_refresh_scn(500200)]), rowset=16                               |
    |       access([MLOG$_COLLECT_ITEM.ITEM_ID], [ORA_ROWSCN]), partitions(p[0-15])                                                                              |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                                                          |
    |       range_key([MLOG$_COLLECT_ITEM.ITEM_ID], [MLOG$_COLLECT_ITEM.SEQUENCE$$]), range(MIN,MIN ; MAX,MAX)always true                                        |
    |  41 - output([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE]), filter(nil), rowset=16                                                                     |
    |       access([COLLECT_ITEM.ITEM_ID], [COLLECT_ITEM.ITEM_TYPE]), partitions(p[0-15])                                                                        |
    |       is_index_back=false, is_global_index=false,                                                                                                          |
    |       range_key([COLLECT_ITEM.ITEM_ID]), range(MIN ; MAX),                                                                                                 |
    |       range_cond([COLLECT_ITEM.ITEM_ID = :14])                                                                                                             |
    |  42 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                       |
    |  43 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                       |
    |       (#keys=1, [COLLECT_INFO.ITEM_ID]), is_single, dop=1                                                                                                  |
    |  44 - output([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), filter(nil), rowset=16                                                                       |
    |       access([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), partitions(p13)                                                                              |
    |       is_index_back=false, is_global_index=false,                                                                                                          |
    |       range_key([COLLECT_INFO.USER_ID], [COLLECT_INFO.ITEM_ID]), range(10000,MIN ; 10000,MAX),                                                             |
    |       range_cond([COLLECT_INFO.USER_ID = cast(10000, NUMBER(-1, -85))])                                                                                    |
    +------------------------------------------------------------------------------------------------------------------------------------------------------------+
    163 rows in set
    ```

## 相关文档

* [CREATE MATERIALIZED VIEW](../../../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1750.create-materialized-views-of-oracle-mode-in-sql.md)
* [创建物化视图](200.create-materialized-views-of-oracle-mode.md)
* [查询物化视图](300.view-materialized-views-of-oracle-mode.md)
* [删除物化视图](400.delete-materialized-views-of-oracle-mode.md)
* [刷新物化视图](500.refresh-materialized-views-of-oracle-mode.md)
