|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# 物化视图改写

物化视图改写实现在输入一个不使用物化视图的查询时，自动通过现有物化视图加速查询。

## 创建物化视图

创建物化视图时，指定 `ENABLE QUERY REWRITE` 开启当前物化视图的自动改写。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><ul><li>本功能需要物化视图仅包含 <code>SELECT JOIN</code> 与 <code>WHERE</code> 子句，对于不满足条件的物化视图，不会报错，但不会被用于改写。</li><li>OceanBase 数据库 Oracle 模式下，创建支持改写的物化视图时必须指定刷新方式（<code>refresh_clause</code>）。</li></ul></p>
</main>

**示例如下：**

1. 创建表 `tbl1`。

    ```sql
    CREATE TABLE tbl1 (col1 INT, col2 INT, col3 INT);
    ```

2. 创建名为 `mv_tbl1` 的物化视图，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv_tbl1
        NEVER REFRESH
        ENABLE QUERY REWRITE
        AS SELECT *
            FROM tbl1;
    ```

控制物化视图改写的系统变量如下：

* `query_rewrite_enabled`：默认值为 `false`，需要手动设置为 `true` 或 `force`。

    **示例如下：**

    ```sql
    SET query_rewrite_enabled = 'force';
    ```

* `query_rewrite_integrity`：默认值为 `enforced`。如果使用了非实时物化视图，需要设置数据一致性 `query_rewrite_integrity` 为 `stale_tolerated`。

    **示例如下：**

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

当输入查询 `SELECT count(*), col1 FROM tbl1 WHERE tbl1.col1 > 1 GROUP BY col1;` 时，发生物化视图改写。

```sql
SELECT count(*), col1 FROM tbl1 WHERE tbl1.col1 > 1 GROUP BY col1;

MV REWRITE ==>

SELECT count(*), mv_tbl1.col1 col1 FROM mv_tbl1 WHERE mv_tbl1.col1 > 1 GROUP BY mv_tbl1.col1;
```

物化视图改写要求输入的查询与物化视图的 `FROM` 完全匹配，`WHERE` 条件包含物化视图中的所有 `WHERE` 条件。

## 物化视图改写控制

物化视图改写控制包括 `MV_REWRITE`、`NO_MV_REWRITE` 两个 Hint，并且这两个 Hint 的优先级高于系统变量 `query_rewrite_enabled`。

### MV_REWRITE

`MV_REWRITE` 语法如下：

```sql
/*+ MV_REWRITE (@ queryblock [mv_name_list]) */

mv_name_list:
    mv_name [, mv_name ...]
```

单独使用 `MV_REWRITE` Hint 时可以跳过物化视图改写的规则/代价检查，直接使用可以使用的改写。Hint 后指定一个或多个物化视图的情况，除了跳过规则/代价检查外，物化视图改写将只使用指定的物化视图尝试改写，忽略所有没被指定的物化视图。

使用 `MV_REWRITE` Hint 指定物化视图时，也无法强制使用没有 `ENABLE QUERY REWRITE`（开启当前物化视图的自动改写） 子句的物化视图，也无法在系统变量 `query_rewrite_integrity` 设置为 `enforced` 的情况下强制使用非实时物化视图。

### NO_MV_REWRITE

`NO_MV_REWRITE` 语法如下：

```sql
/*+ NO_MV_REWRITE (@ queryblock) */
```

禁止物化视图改写，可以指定 query block。

### 物化视图改写控制 Hint 使用示例

1. 创建基表 `tbl2`。

    ```sql
    CREATE TABLE tbl2 (col1 INT, col2 INT);
    ```

2. 向基表 `tbl2` 中插入两条数据。

    ```sql
    INSERT INTO tbl2 VALUES (1,2),(3,4);
    ```

    返回结果如下：

    ```shell
    Query OK, 2 rows affected
    Records: 2  Duplicates: 0  Warnings: 0
    ```

3. 创建物化视图 `mv1_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv1_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2;
    ```

4. 创建物化视图 `mv2_tbl2`，并开启当前物化视图的自动改写。

    ```sql
    CREATE MATERIALIZED VIEW mv2_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2 WHERE tbl2.col1 > 1;
    ```

5. 设置系统变量 `query_rewrite_integrity` 为 `stale_tolerated`。

    <main id="notice" type='explain'>
      <h4>说明</h4>
      <p><code>MV_REWRITE</code> 和 <code>NO_MV_REWRITE</code> Hint 的优先级高于系统变量 <code>query_rewrite_enabled</code>，因此不需要设置 <code>query_rewrite_enabled</code>。但是需要设置 <code>query_rewrite_integrity</code> 为 <code>stale_tolerated</code> 才可以使用非实时物化视图进行改写。</p>
    </main>

    ```sql
    SET query_rewrite_integrity = 'stale_tolerated';
    ```

6. 使用 `MV_REWRITE` Hint 用物化视图尝试进行改写，并跳过改写代价/规则检查。下面两条查询都将使用物化视图 `mv1_tbl2` 进行改写。

   * `/*+mv_rewrite*/` 将用所有物化视图尝试进行改写，并跳过改写代价/规则检查。

       ```sql
       EXPLAIN SELECT /*+mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
       ```

       返回结果如下：

       ```shell
       +----------------------------------------------------------------------------------------------+
       | Query Plan                                                                                   |
       +----------------------------------------------------------------------------------------------+
       | =====================================================                                        |
       | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                                        |
       | -----------------------------------------------------                                        |
       | |0 |HASH GROUP BY    |        |1       |3           |                                        |
       | |1 |└─TABLE FULL SCAN|MV1_TBL2|1       |3           |                                        |
       | =====================================================                                        |
       | Outputs & filters:                                                                           |
       | -------------------------------------                                                        |
       |   0 - output([T_FUN_COUNT(*)], [MV1_TBL2.COL1]), filter(nil), rowset=16                      |
       |       group([MV1_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                     |
       |   1 - output([MV1_TBL2.COL1]), filter([MV1_TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
       |       access([MV1_TBL2.COL1]), partitions(p0)                                                |
       |       is_index_back=false, is_global_index=false, filter_before_indexback[false],            |
       |       range_key([MV1_TBL2.__pk_increment]), range(MIN ; MAX)always true                      |
       +----------------------------------------------------------------------------------------------+
       14 rows in set
       ```

   * `/*+mv_rewrite(mv1_tbl2)*/` 将尝试使用 `mv1_tbl2` 进行改写，并跳过改写代价/规则检查。

       ```sql
       EXPLAIN SELECT /*+mv_rewrite(mv1_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
       ```

       返回结果如下：

       ```shell
       +----------------------------------------------------------------------------------------------+
       | Query Plan                                                                                   |
       +----------------------------------------------------------------------------------------------+
       | =====================================================                                        |
       | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                                        |
       | -----------------------------------------------------                                        |
       | |0 |HASH GROUP BY    |        |1       |3           |                                        |
       | |1 |└─TABLE FULL SCAN|MV1_TBL2|1       |3           |                                        |
       | =====================================================                                        |
       | Outputs & filters:                                                                           |
       | -------------------------------------                                                        |
       |   0 - output([T_FUN_COUNT(*)], [MV1_TBL2.COL1]), filter(nil), rowset=16                      |
       |       group([MV1_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                     |
       |   1 - output([MV1_TBL2.COL1]), filter([MV1_TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
       |       access([MV1_TBL2.COL1]), partitions(p0)                                                |
       |       is_index_back=false, is_global_index=false, filter_before_indexback[false],            |
       |       range_key([MV1_TBL2.__pk_increment]), range(MIN ; MAX)always true                      |
       +----------------------------------------------------------------------------------------------+
       14 rows in set
       ```

7. 由于 `mv2_tbl2` 无法用于下面查询的改写（`WHERE` 条件不满足），下面的查询只尝试使用 `mv2_tbl2`，因此无法使用其他物化视图改写，不会进行物化视图改写。

    ```sql
    EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +-------------------------------------------------------------------------+
    | Query Plan                                                              |
    +-------------------------------------------------------------------------+
    | =====================================================                   |
    | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                   |
    | -----------------------------------------------------                   |
    | |0 |HASH GROUP BY    |        |1       |3           |                   |
    | |1 |└─TABLE FULL SCAN|MV2_TBL2|1       |3           |                   |
    | =====================================================                   |
    | Outputs & filters:                                                      |
    | -------------------------------------                                   |
    |   0 - output([T_FUN_COUNT(*)], [MV2_TBL2.COL1]), filter(nil), rowset=16 |
    |       group([MV2_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                |
    |   1 - output([MV2_TBL2.COL1]), filter(nil), rowset=16                   |
    |       access([MV2_TBL2.COL1]), partitions(p0)                           |
    |       is_index_back=false, is_global_index=false,                       |
    |       range_key([MV2_TBL2.__pk_increment]), range(MIN ; MAX)always true |
    +-------------------------------------------------------------------------+
    14 rows in set
    ```

8. 使用 `/*+ no_mv_rewrite*/` Hint，不会进行物化视图改写。

    ```sql
    EXPLAIN SELECT /*+no_mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
    ```

    返回结果如下：

    ```shell
    +--------------------------------------------------------------------------------------+
    | Query Plan                                                                           |
    +--------------------------------------------------------------------------------------+
    | =================================================                                    |
    | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                    |
    | -------------------------------------------------                                    |
    | |0 |HASH GROUP BY    |    |1       |3           |                                    |
    | |1 |└─TABLE FULL SCAN|TBL2|1       |3           |                                    |
    | =================================================                                    |
    | Outputs & filters:                                                                   |
    | -------------------------------------                                                |
    |   0 - output([T_FUN_COUNT(*)], [TBL2.COL1]), filter(nil), rowset=16                  |
    |       group([TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                 |
    |   1 - output([TBL2.COL1]), filter([TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
    |       access([TBL2.COL1]), partitions(p0)                                            |
    |       is_index_back=false, is_global_index=false, filter_before_indexback[false],    |
    |       range_key([TBL2.__pk_increment]), range(MIN ; MAX)always true                  |
    +--------------------------------------------------------------------------------------+
    14 rows in set
    ```

## 相关文档

* [CREATE MATERIALIZED VIEW](../../../../../500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/1750.create-materialized-views-of-oracle-mode-in-sql.md)
* [创建物化视图](200.create-materialized-views-of-oracle-mode.md)
* [查询物化视图](300.view-materialized-views-of-oracle-mode.md)
* [删除物化视图](400.delete-materialized-views-of-oracle-mode.md)
* [刷新物化视图](500.refresh-materialized-views-of-oracle-mode.md)
